<page>
---
title: Overview · Cloudflare Sandbox SDK docs
description: The Sandbox SDK enables you to run untrusted code securely in
  isolated environments. Built on Containers, Sandbox SDK provides a simple API
  for executing commands, managing files, running background processes, and
  exposing services — all from your Workers applications.
lastUpdated: 2026-02-09T23:08:08.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/
  md: https://developers.cloudflare.com/sandbox/index.md
---

Build secure, isolated code execution environments

Available on Workers Paid plan

The Sandbox SDK enables you to run untrusted code securely in isolated environments. Built on [Containers](https://developers.cloudflare.com/containers/), Sandbox SDK provides a simple API for executing commands, managing files, running background processes, and exposing services — all from your [Workers](https://developers.cloudflare.com/workers/) applications.

Sandboxes are ideal for building AI agents that need to execute code, interactive development environments, data analysis platforms, CI/CD systems, and any application that needs secure code execution at the edge. Each sandbox runs in its own isolated container with a full Linux environment, providing strong security boundaries while maintaining performance.

With Sandbox, you can execute Python scripts, run Node.js applications, analyze data, compile code, and perform complex computations — all with a simple TypeScript API and no infrastructure to manage.

* Execute Commands

  ```typescript
  import { getSandbox } from '@cloudflare/sandbox';


  export { Sandbox } from '@cloudflare/sandbox';


  export default {
    async fetch(request: Request, env: Env): Promise<Response> {
      const sandbox = getSandbox(env.Sandbox, 'user-123');


      // Execute a command and get the result
      const result = await sandbox.exec('python --version');


      return Response.json({
        output: result.stdout,
        exitCode: result.exitCode,
        success: result.success
      });
    }
  };
  ```

* Code Interpreter

  ```typescript
  import { getSandbox } from '@cloudflare/sandbox';


  export { Sandbox } from '@cloudflare/sandbox';


  export default {
    async fetch(request: Request, env: Env): Promise<Response> {
      const sandbox = getSandbox(env.Sandbox, 'user-123');


      // Create a Python execution context
      const ctx = await sandbox.createCodeContext({ language: 'python' });


      // Execute Python code with automatic result capture
      const result = await sandbox.runCode(`
  import pandas as pd
  data = {'product': ['A', 'B', 'C'], 'sales': [100, 200, 150]}
  df = pd.DataFrame(data)
  df['sales'].sum()  # Last expression is automatically returned
    `, { context: ctx });


        return Response.json({
          result: result.results?.[0]?.text,
          logs: result.logs
        });
      }
    };
  ```

* File Operations

  ```typescript
  import { getSandbox } from '@cloudflare/sandbox';


  export { Sandbox } from '@cloudflare/sandbox';


  export default {
    async fetch(request: Request, env: Env): Promise<Response> {
      const sandbox = getSandbox(env.Sandbox, 'user-123');


      // Create a project structure
      await sandbox.mkdir('/workspace/project/src', { recursive: true });


      // Write files
      await sandbox.writeFile(
        '/workspace/project/package.json',
        JSON.stringify({ name: 'my-app', version: '1.0.0' })
      );


      // Read a file back
      const content = await sandbox.readFile('/workspace/project/package.json');


      return Response.json({ content });
    }
  };
  ```

* File Watching

  ```typescript
  import { getSandbox } from '@cloudflare/sandbox';


  export { Sandbox } from '@cloudflare/sandbox';


  export default {
    async fetch(request: Request, env: Env): Promise<Response> {
      const sandbox = getSandbox(env.Sandbox, 'user-123');


      // Watch for file changes in real-time
      const watcher = await sandbox.watch('/workspace/src', {
        include: ['*.js', '*.ts'],
        onEvent: (event) => {
          console.log(`${event.type}: ${event.path}`);
          if (event.type === 'modify') {
            // Trigger rebuild or hot reload
            console.log('Code changed, recompiling...');
          }
        },
        onError: (error) => {
          console.error('Watch error:', error);
        }
      });


      // Stop watching when done
      setTimeout(() => watcher.stop(), 60000);


      return Response.json({ message: 'File watcher started' });
    }
  };
  ```

* Terminal Access

  ```typescript
  import { getSandbox } from '@cloudflare/sandbox';


  export { Sandbox } from '@cloudflare/sandbox';


  export default {
    async fetch(request: Request, env: Env): Promise<Response> {
      const url = new URL(request.url);


      // Terminal WebSocket connection
      if (url.pathname === '/ws/terminal') {
        const sandbox = getSandbox(env.Sandbox, 'user-123');
        return sandbox.terminal(request, { cols: 80, rows: 24 });
      }


      return Response.json({ message: 'Terminal endpoint' });
    }
  };
  ```

  Connect browser terminals directly to sandbox shells via WebSocket. Learn more: [Browser terminals](https://developers.cloudflare.com/sandbox/guides/browser-terminals/).

* WebSocket Connections

  ```typescript
  import { getSandbox } from '@cloudflare/sandbox';


  export { Sandbox } from '@cloudflare/sandbox';


  export default {
    async fetch(request: Request, env: Env): Promise<Response> {
      // Connect to WebSocket services in sandbox
      if (request.headers.get('Upgrade')?.toLowerCase() === 'websocket') {
        const sandbox = getSandbox(env.Sandbox, 'user-123');
        return await sandbox.wsConnect(request, 8080);
      }


      return Response.json({ message: 'WebSocket endpoint' });
    }
  };
  ```

  Connect to WebSocket servers running in sandboxes. Learn more: [WebSocket Connections](https://developers.cloudflare.com/sandbox/guides/websocket-connections/).

[Get started](https://developers.cloudflare.com/sandbox/get-started/)

[API Reference](https://developers.cloudflare.com/sandbox/api/)

***

## Features

### Execute commands securely

Run shell commands, Python scripts, Node.js applications, and more with streaming output support and automatic timeout handling.

[Learn about command execution](https://developers.cloudflare.com/sandbox/guides/execute-commands/)

### Manage files and processes

Read, write, and manipulate files in the sandbox filesystem. Run background processes, monitor output, and manage long-running operations.

[Learn about file operations](https://developers.cloudflare.com/sandbox/guides/manage-files/)

### Expose services with preview URLs

Expose HTTP services running in your sandbox with automatically generated preview URLs, perfect for interactive development environments and application hosting.

[Learn about preview URLs](https://developers.cloudflare.com/sandbox/guides/expose-services/)

### Execute code directly

Execute Python and JavaScript code with rich outputs including charts, tables, and images. Maintain persistent state between executions for AI-generated code and interactive workflows.

[Learn about code execution](https://developers.cloudflare.com/sandbox/guides/code-execution/)

### Build interactive terminals

Create browser-based terminal interfaces that connect directly to sandbox shells via WebSocket. Build collaborative terminals, interactive development environments, and real-time shell access with automatic reconnection.

[Learn about terminal UIs](https://developers.cloudflare.com/sandbox/guides/browser-terminals/)

### Persistent storage with object storage

Mount S3-compatible object storage (R2, S3, GCS, and more) as local filesystems. Access buckets using standard file operations with data that persists across sandbox lifecycles. Production deployment required.

[Learn about bucket mounting](https://developers.cloudflare.com/sandbox/guides/mount-buckets/)

### Watch files for real-time changes

Monitor files and directories for changes using native filesystem events. Perfect for building hot reloading development servers, build automation systems, and configuration monitoring tools.

[Learn about file watching](https://developers.cloudflare.com/sandbox/guides/file-watching/)

***

## Use Cases

Build powerful applications with Sandbox:

### AI Code Execution

Execute code generated by Large Language Models safely and reliably. Native integration with [Workers AI](https://developers.cloudflare.com/workers-ai/) models like GPT-OSS enables function calling with sandbox execution. Perfect for AI agents, code assistants, and autonomous systems that need to run untrusted code.

### Data Analysis & Notebooks

Create interactive data analysis environments with pandas, NumPy, and Matplotlib. Generate charts, tables, and visualizations with automatic rich output formatting.

### Interactive Development Environments

Build cloud IDEs, coding playgrounds, and collaborative development tools with full Linux environments and preview URLs.

### CI/CD & Build Systems

Run tests, compile code, and execute build pipelines in isolated environments with parallel execution and streaming logs.

***

## Related products

**[Containers](https://developers.cloudflare.com/containers/)**

Serverless container runtime that powers Sandbox, enabling you to run any containerized workload on the edge.

**[Workers AI](https://developers.cloudflare.com/workers-ai/)**

Run machine learning models and LLMs on the network. Combine with Sandbox for secure AI code execution workflows.

**[Durable Objects](https://developers.cloudflare.com/durable-objects/)**

Stateful coordination layer that enables Sandbox to maintain persistent environments with strong consistency.

***

## More resources

[Tutorials](https://developers.cloudflare.com/sandbox/tutorials/)

Explore complete examples including AI code execution, data analysis, and interactive environments.

[How-to Guides](https://developers.cloudflare.com/sandbox/guides/)

Learn how to solve specific problems and implement features with the Sandbox SDK.

[API Reference](https://developers.cloudflare.com/sandbox/api/)

Explore the complete API documentation for the Sandbox SDK.

[Concepts](https://developers.cloudflare.com/sandbox/concepts/)

Learn about the key concepts and architecture of the Sandbox SDK.

[Configuration](https://developers.cloudflare.com/sandbox/configuration/)

Learn about the configuration options for the Sandbox SDK.

[GitHub Repository](https://github.com/cloudflare/sandbox-sdk)

View the SDK source code, report issues, and contribute to the project.

[Beta Information](https://developers.cloudflare.com/sandbox/platform/beta-info/)

Learn about the Sandbox Beta, current status, and upcoming features.

[Pricing](https://developers.cloudflare.com/sandbox/platform/pricing/)

Understand Sandbox pricing based on the underlying Containers platform.

[Limits](https://developers.cloudflare.com/sandbox/platform/limits/)

Learn about resource limits, quotas, and best practices for working within them.

[Discord Community](https://discord.cloudflare.com)

Connect with the community on Discord. Ask questions, share what you're building, and get help from other developers.

</page>

<page>
---
title: 404 - Page Not Found · Cloudflare Sandbox SDK docs
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/404/
  md: https://developers.cloudflare.com/sandbox/404/index.md
---

# 404

Check the URL, try using our [search](https://developers.cloudflare.com/search/) or try our LLM-friendly [llms.txt directory](https://developers.cloudflare.com/llms.txt).

</page>

<page>
---
title: API Reference · Cloudflare Sandbox SDK docs
description: The Sandbox SDK provides a comprehensive API for executing code,
  managing files, running processes, and exposing services in isolated
  sandboxes.
lastUpdated: 2026-02-09T23:08:08.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/api/
  md: https://developers.cloudflare.com/sandbox/api/index.md
---

The Sandbox SDK provides a comprehensive API for executing code, managing files, running processes, and exposing services in isolated sandboxes.

[Lifecycle](https://developers.cloudflare.com/sandbox/api/lifecycle/)

Create and manage sandbox containers. Get sandbox instances, configure options, and clean up resources.

[Commands](https://developers.cloudflare.com/sandbox/api/commands/)

Execute commands and stream output. Run scripts, manage background processes, and capture execution results.

[Files](https://developers.cloudflare.com/sandbox/api/files/)

Read, write, and manage files in the sandbox filesystem. Includes directory operations and file metadata.

[File Watching](https://developers.cloudflare.com/sandbox/api/file-watching/)

Monitor real-time filesystem changes using native inotify. Build development tools, hot-reload systems, and responsive file processing.

[Code Interpreter](https://developers.cloudflare.com/sandbox/api/interpreter/)

Execute Python and JavaScript code with rich outputs including charts, tables, and formatted data.

[Ports](https://developers.cloudflare.com/sandbox/api/ports/)

Expose services running in the sandbox via preview URLs. Access web servers and APIs from the internet.

[Storage](https://developers.cloudflare.com/sandbox/api/storage/)

Mount S3-compatible buckets (R2, S3, GCS) as local filesystems for persistent data storage across sandbox lifecycles.

[Sessions](https://developers.cloudflare.com/sandbox/api/sessions/)

Create isolated execution contexts within a sandbox. Each session maintains its own shell state, environment variables, and working directory.

[Terminal](https://developers.cloudflare.com/sandbox/api/terminal/)

Connect browser-based terminal UIs to sandbox shells via WebSocket, with the xterm.js SandboxAddon for automatic reconnection and resize handling.

</page>

<page>
---
title: Concepts · Cloudflare Sandbox SDK docs
description: These pages explain how the Sandbox SDK works, why it's designed
  the way it is, and the concepts you need to understand to use it effectively.
lastUpdated: 2026-02-09T23:08:08.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/concepts/
  md: https://developers.cloudflare.com/sandbox/concepts/index.md
---

These pages explain how the Sandbox SDK works, why it's designed the way it is, and the concepts you need to understand to use it effectively.

* [Architecture](https://developers.cloudflare.com/sandbox/concepts/architecture/) - How the SDK is structured and why
* [Sandbox lifecycle](https://developers.cloudflare.com/sandbox/concepts/sandboxes/) - Understanding sandbox states and behavior
* [Container runtime](https://developers.cloudflare.com/sandbox/concepts/containers/) - How code executes in isolated containers
* [Session management](https://developers.cloudflare.com/sandbox/concepts/sessions/) - When and how to use sessions
* [Preview URLs](https://developers.cloudflare.com/sandbox/concepts/preview-urls/) - How service exposure works
* [Security model](https://developers.cloudflare.com/sandbox/concepts/security/) - Isolation, validation, and safety mechanisms
* [Terminal connections](https://developers.cloudflare.com/sandbox/concepts/terminal/) - How browser terminal connections work

## Related resources

* [Tutorials](https://developers.cloudflare.com/sandbox/tutorials/) - Learn by building complete applications
* [How-to guides](https://developers.cloudflare.com/sandbox/guides/) - Solve specific problems
* [API reference](https://developers.cloudflare.com/sandbox/api/) - Technical details and method signatures

</page>

<page>
---
title: Configuration · Cloudflare Sandbox SDK docs
description: Configure your Sandbox SDK deployment with Wrangler, customize
  container images, and manage environment variables.
lastUpdated: 2026-02-10T11:20:23.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/configuration/
  md: https://developers.cloudflare.com/sandbox/configuration/index.md
---

Configure your Sandbox SDK deployment with Wrangler, customize container images, and manage environment variables.

[Wrangler configuration](https://developers.cloudflare.com/sandbox/configuration/wrangler/)

Configure Durable Objects bindings, container images, and Worker settings in wrangler.jsonc.

[Dockerfile reference](https://developers.cloudflare.com/sandbox/configuration/dockerfile/)

Customize the sandbox container image with your own packages, tools, and configurations.

[Environment variables](https://developers.cloudflare.com/sandbox/configuration/environment-variables/)

Pass configuration and secrets to your sandboxes using environment variables.

[Transport modes](https://developers.cloudflare.com/sandbox/configuration/transport/)

Configure HTTP or WebSocket transport to optimize communication and avoid subrequest limits.

[Sandbox options](https://developers.cloudflare.com/sandbox/configuration/sandbox-options/)

Configure sandbox behavior with options like `keepAlive` for long-running processes.

## Related resources

* [Get Started guide](https://developers.cloudflare.com/sandbox/get-started/) - Initial setup walkthrough
* [Wrangler documentation](https://developers.cloudflare.com/workers/wrangler/) - Complete Wrangler reference
* [Docker documentation](https://docs.docker.com/engine/reference/builder/) - Dockerfile syntax
* [Security model](https://developers.cloudflare.com/sandbox/concepts/security/) - Understanding environment isolation

</page>

<page>
---
title: Getting started · Cloudflare Sandbox SDK docs
description: Build your first application with Sandbox SDK - a secure code
  execution environment. In this guide, you'll create a Worker that can execute
  Python code and work with files in isolated containers.
lastUpdated: 2026-02-06T17:12:25.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/get-started/
  md: https://developers.cloudflare.com/sandbox/get-started/index.md
---

Build your first application with Sandbox SDK - a secure code execution environment. In this guide, you'll create a Worker that can execute Python code and work with files in isolated containers.

What you're building

A simple API that can safely execute Python code and perform file operations in isolated sandbox environments.

## Prerequisites

1. Sign up for a [Cloudflare account](https://dash.cloudflare.com/sign-up/workers-and-pages).
2. Install [`Node.js`](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm).

Node.js version manager

Use a Node version manager like [Volta](https://volta.sh/) or [nvm](https://github.com/nvm-sh/nvm) to avoid permission issues and change Node.js versions. [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/), discussed later in this guide, requires a Node version of `16.17.0` or later.

### Ensure Docker is running locally

Sandbox SDK uses [Docker](https://www.docker.com/) to build container images alongside your Worker.

You must have Docker running locally when you run `wrangler deploy`. For most people, the best way to install Docker is to follow the [docs for installing Docker Desktop](https://docs.docker.com/desktop/). Other tools like [Colima](https://github.com/abiosoft/colima) may also work.

You can check that Docker is running properly by running the `docker info` command in your terminal. If Docker is running, the command will succeed. If Docker is not running, the `docker info` command will hang or return an error including the message "Cannot connect to the Docker daemon".

## 1. Create a new project

Create a new Sandbox SDK project:

* npm

  ```sh
  npm create cloudflare@latest -- my-sandbox --template=cloudflare/sandbox-sdk/examples/minimal
  ```

* yarn

  ```sh
  yarn create cloudflare my-sandbox --template=cloudflare/sandbox-sdk/examples/minimal
  ```

* pnpm

  ```sh
  pnpm create cloudflare@latest my-sandbox --template=cloudflare/sandbox-sdk/examples/minimal
  ```

This creates a `my-sandbox` directory with everything you need:

* `src/index.ts` - Worker with sandbox integration
* `wrangler.jsonc` - Configuration for Workers and Containers
* `Dockerfile` - Container environment definition

```sh
cd my-sandbox
```

## 2. Explore the template

The template provides a minimal Worker that demonstrates core sandbox capabilities:

```typescript
import { getSandbox, proxyToSandbox, type Sandbox } from "@cloudflare/sandbox";


export { Sandbox } from "@cloudflare/sandbox";


type Env = {
  Sandbox: DurableObjectNamespace<Sandbox>;
};


export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);


    // Get or create a sandbox instance
    const sandbox = getSandbox(env.Sandbox, "my-sandbox");


    // Execute Python code
    if (url.pathname === "/run") {
      const result = await sandbox.exec('python3 -c "print(2 + 2)"');
      return Response.json({
        output: result.stdout,
        error: result.stderr,
        exitCode: result.exitCode,
        success: result.success,
      });
    }


    // Work with files
    if (url.pathname === "/file") {
      await sandbox.writeFile("/workspace/hello.txt", "Hello, Sandbox!");
      const file = await sandbox.readFile("/workspace/hello.txt");
      return Response.json({
        content: file.content,
      });
    }


    return new Response("Try /run or /file");
  },
};
```

**Key concepts**:

* `getSandbox()` - Gets or creates a sandbox instance by ID. Use the same ID to reuse the same sandbox instance across requests.
* `sandbox.exec()` - Execute shell commands in the sandbox and capture stdout, stderr, and exit codes.
* `sandbox.writeFile()` / `readFile()` - Write and read files in the sandbox filesystem.

## 3. Test locally

Start the development server:

```sh
npm run dev
# If you expect to have multiple sandbox instances, you can increase `max_instances`.
```

Note

First run builds the Docker container (2-3 minutes). Subsequent runs are much faster due to caching.

Test the endpoints:

```sh
# Execute Python code
curl http://localhost:8787/run


# File operations
curl http://localhost:8787/file
```

You should see JSON responses with the command output and file contents.

## 4. Deploy to production

Deploy your Worker and container:

```sh
npx wrangler deploy
```

This will:

1. Build your container image using Docker
2. Push it to Cloudflare's Container Registry
3. Deploy your Worker globally

Wait for provisioning

After first deployment, wait 2-3 minutes before making requests. The Worker deploys immediately, but the container needs time to provision.

Check deployment status:

```sh
npx wrangler containers list
```

## 5. Test your deployment

Visit your Worker URL (shown in deploy output):

```sh
# Replace with your actual URL
curl https://my-sandbox.YOUR_SUBDOMAIN.workers.dev/run
```

Your sandbox is now deployed and can execute code in isolated containers.

Preview URLs require custom domain

If you plan to expose ports from sandboxes (using `exposePort()` for preview URLs), you will need to set up a custom domain with wildcard DNS routing. The `.workers.dev` domain does not support the subdomain patterns required for preview URLs. See [Production Deployment](https://developers.cloudflare.com/sandbox/guides/production-deployment/) when you are ready to expose services.

## Understanding the configuration

Your `wrangler.jsonc` connects three pieces together:

* wrangler.jsonc

  ```jsonc
  {
    "containers": [
      {
        "class_name": "Sandbox",
        "image": "./Dockerfile",
        "instance_type": "lite",
        "max_instances": 1,
      },
    ],
    "durable_objects": {
      "bindings": [
        {
          "class_name": "Sandbox",
          "name": "Sandbox",
        },
      ],
    },
    "migrations": [
      {
        "new_sqlite_classes": ["Sandbox"],
        "tag": "v1",
      },
    ],
  }
  ```

* wrangler.toml

  ```toml
  [[containers]]
  class_name = "Sandbox"
  image = "./Dockerfile"
  instance_type = "lite"
  max_instances = 1


  [[durable_objects.bindings]]
  class_name = "Sandbox"
  name = "Sandbox"


  [[migrations]]
  new_sqlite_classes = [ "Sandbox" ]
  tag = "v1"
  ```

- **containers** - Defines the [container image, instance type, and resource limits](https://developers.cloudflare.com/workers/wrangler/configuration/#containers) for your sandbox environment. If you expect to have multiple sandbox instances, you can increase `max_instances`.
- **durable\_objects** - You need not be familiar with [Durable Objects](https://developers.cloudflare.com/durable-objects) to use Sandbox SDK, but if you'd like, you can [learn more about Cloudflare Containers and Durable Objects](https://developers.cloudflare.com/containers/get-started/#each-container-is-backed-by-its-own-durable-object). This configuration creates a [binding](https://developers.cloudflare.com/workers/runtime-apis/bindings#what-is-a-binding) that makes the `Sandbox` Durable Object accessible in your Worker code.
- **migrations** - Registers the `Sandbox` class, implemented by the Sandbox SDK, with [SQLite storage backend](https://developers.cloudflare.com/durable-objects/best-practices/access-durable-objects-storage) (required once)

For detailed configuration options including environment variables, secrets, and custom images, see the [Wrangler configuration reference](https://developers.cloudflare.com/sandbox/configuration/wrangler/).

## Next steps

Now that you have a working sandbox, explore more capabilities:

* [Code interpreter with Workers AI](https://developers.cloudflare.com/sandbox/tutorials/workers-ai-code-interpreter/) - Build an AI-powered code execution system
* [Execute commands](https://developers.cloudflare.com/sandbox/guides/execute-commands/) - Run shell commands and stream output
* [Manage files](https://developers.cloudflare.com/sandbox/guides/manage-files/) - Work with files and directories
* [Expose services](https://developers.cloudflare.com/sandbox/guides/expose-services/) - Get public URLs for services running in your sandbox
* [Production Deployment](https://developers.cloudflare.com/sandbox/guides/production-deployment/) - Set up custom domains for preview URLs
* [API reference](https://developers.cloudflare.com/sandbox/api/) - Complete API documentation

</page>

<page>
---
title: Platform · Cloudflare Sandbox SDK docs
description: Information about the Sandbox SDK platform, including pricing,
  limits, and beta status.
lastUpdated: 2025-10-15T17:28:03.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/platform/
  md: https://developers.cloudflare.com/sandbox/platform/index.md
---

Information about the Sandbox SDK platform, including pricing, limits, and beta status.

## Available resources

* [Pricing](https://developers.cloudflare.com/sandbox/platform/pricing/) - Understand costs based on the Containers platform
* [Limits](https://developers.cloudflare.com/sandbox/platform/limits/) - Resource limits and best practices
* [Beta Information](https://developers.cloudflare.com/sandbox/platform/beta-info/) - Current status and roadmap

Since Sandbox SDK is built on [Containers](https://developers.cloudflare.com/containers/), it shares the same underlying platform characteristics. Refer to these pages to understand how pricing and limits work for your sandbox deployments.

</page>

<page>
---
title: How-to guides · Cloudflare Sandbox SDK docs
description: These guides show you how to solve specific problems and implement
  features with the Sandbox SDK. Each guide focuses on a particular task and
  provides practical, production-ready solutions.
lastUpdated: 2025-10-21T14:02:11.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/guides/
  md: https://developers.cloudflare.com/sandbox/guides/index.md
---

These guides show you how to solve specific problems and implement features with the Sandbox SDK. Each guide focuses on a particular task and provides practical, production-ready solutions.

[Run background processes](https://developers.cloudflare.com/sandbox/guides/background-processes/)

[Start and manage long-running services and applications.](https://developers.cloudflare.com/sandbox/guides/background-processes/)

[Browser terminals](https://developers.cloudflare.com/sandbox/guides/browser-terminals/)

[Connect browser-based terminals to sandbox shells using xterm.js or raw WebSockets.](https://developers.cloudflare.com/sandbox/guides/browser-terminals/)

[Use code interpreter](https://developers.cloudflare.com/sandbox/guides/code-execution/)

[Execute Python and JavaScript code with rich outputs.](https://developers.cloudflare.com/sandbox/guides/code-execution/)

[Execute commands](https://developers.cloudflare.com/sandbox/guides/execute-commands/)

[Run commands with streaming output, error handling, and shell access.](https://developers.cloudflare.com/sandbox/guides/execute-commands/)

[Expose services](https://developers.cloudflare.com/sandbox/guides/expose-services/)

[Create preview URLs and expose ports for web services.](https://developers.cloudflare.com/sandbox/guides/expose-services/)

[Watch filesystem changes](https://developers.cloudflare.com/sandbox/guides/file-watching/)

[Monitor files and directories in real-time to build responsive development tools and automation workflows.](https://developers.cloudflare.com/sandbox/guides/file-watching/)

[Work with Git](https://developers.cloudflare.com/sandbox/guides/git-workflows/)

[Clone repositories, manage branches, and automate Git operations.](https://developers.cloudflare.com/sandbox/guides/git-workflows/)

[Manage files](https://developers.cloudflare.com/sandbox/guides/manage-files/)

[Read, write, organize, and synchronize files in the sandbox.](https://developers.cloudflare.com/sandbox/guides/manage-files/)

[Mount buckets](https://developers.cloudflare.com/sandbox/guides/mount-buckets/)

[Mount S3-compatible object storage as local filesystems for persistent data storage.](https://developers.cloudflare.com/sandbox/guides/mount-buckets/)

[Deploy to Production](https://developers.cloudflare.com/sandbox/guides/production-deployment/)

[Set up custom domains for preview URLs in production.](https://developers.cloudflare.com/sandbox/guides/production-deployment/)

[Stream output](https://developers.cloudflare.com/sandbox/guides/streaming-output/)

[Handle real-time output from commands and processes.](https://developers.cloudflare.com/sandbox/guides/streaming-output/)

[WebSocket Connections](https://developers.cloudflare.com/sandbox/guides/websocket-connections/)

[Connect to WebSocket servers running in sandboxes.](https://developers.cloudflare.com/sandbox/guides/websocket-connections/)

## Related resources

* [Tutorials](https://developers.cloudflare.com/sandbox/tutorials/) - Step-by-step learning paths
* [API reference](https://developers.cloudflare.com/sandbox/api/) - Complete method documentation

</page>

<page>
---
title: Tutorials · Cloudflare Sandbox SDK docs
description: Learn how to build applications with Sandbox SDK through
  step-by-step tutorials. Each tutorial takes 20-30 minutes.
lastUpdated: 2025-10-21T14:02:11.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/tutorials/
  md: https://developers.cloudflare.com/sandbox/tutorials/index.md
---

Learn how to build applications with Sandbox SDK through step-by-step tutorials. Each tutorial takes 20-30 minutes.

[Code interpreter with Workers AI](https://developers.cloudflare.com/sandbox/tutorials/workers-ai-code-interpreter/)

[Build a code interpreter using Workers AI GPT-OSS model with the official workers-ai-provider package.](https://developers.cloudflare.com/sandbox/tutorials/workers-ai-code-interpreter/)

[Data persistence with R2](https://developers.cloudflare.com/sandbox/tutorials/persistent-storage/)

[Mount R2 buckets as local filesystem paths to persist data across sandbox lifecycles.](https://developers.cloudflare.com/sandbox/tutorials/persistent-storage/)

[Run Claude Code on a Sandbox](https://developers.cloudflare.com/sandbox/tutorials/claude-code/)

[Use Claude Code to implement a task in your GitHub repository.](https://developers.cloudflare.com/sandbox/tutorials/claude-code/)

[Build an AI code executor](https://developers.cloudflare.com/sandbox/tutorials/ai-code-executor/)

[Use Claude to generate Python code from natural language and execute it securely in sandboxes.](https://developers.cloudflare.com/sandbox/tutorials/ai-code-executor/)

[Analyze data with AI](https://developers.cloudflare.com/sandbox/tutorials/analyze-data-with-ai/)

[Upload CSV files, generate analysis code with Claude, and return visualizations.](https://developers.cloudflare.com/sandbox/tutorials/analyze-data-with-ai/)

[Automated testing pipeline](https://developers.cloudflare.com/sandbox/tutorials/automated-testing-pipeline/)

[Build a testing pipeline that clones Git repositories, installs dependencies, runs tests, and reports results.](https://developers.cloudflare.com/sandbox/tutorials/automated-testing-pipeline/)

[Build a code review bot](https://developers.cloudflare.com/sandbox/tutorials/code-review-bot/)

[Clone repositories, analyze code with Claude, and post review comments to GitHub PRs.](https://developers.cloudflare.com/sandbox/tutorials/code-review-bot/)

## Before you start

All tutorials assume you have:

* Completed the [Get Started guide](https://developers.cloudflare.com/sandbox/get-started/)
* Basic familiarity with [Workers](https://developers.cloudflare.com/workers/)
* [Docker](https://www.docker.com/) installed and running

## Related resources

* [How-to guides](https://developers.cloudflare.com/sandbox/guides/) - Solve specific problems
* [API reference](https://developers.cloudflare.com/sandbox/api/) - Complete SDK reference

</page>

<page>
---
title: Commands · Cloudflare Sandbox SDK docs
description: Execute commands and manage background processes in the sandbox's
  isolated container environment.
lastUpdated: 2026-02-08T17:19:50.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/api/commands/
  md: https://developers.cloudflare.com/sandbox/api/commands/index.md
---

Execute commands and manage background processes in the sandbox's isolated container environment.

## Methods

### `exec()`

Execute a command and return the complete result.

```ts
const result = await sandbox.exec(command: string, options?: ExecOptions): Promise<ExecuteResponse>
```

**Parameters**:

* `command` - The command to execute (can include arguments)

* `options` (optional):

  * `stream` - Enable streaming callbacks (default: `false`)
  * `onOutput` - Callback for real-time output: `(stream: 'stdout' | 'stderr', data: string) => void`
  * `timeout` - Maximum execution time in milliseconds
  * `env` - Environment variables for this command: `Record<string, string | undefined>`
  * `cwd` - Working directory for this command
  * `stdin` - Data to pass to the command's standard input (enables arbitrary input without shell injection risks)

**Returns**: `Promise<ExecuteResponse>` with `success`, `stdout`, `stderr`, `exitCode`

* JavaScript

  ```js
  const result = await sandbox.exec("npm run build");


  if (result.success) {
    console.log("Build output:", result.stdout);
  } else {
    console.error("Build failed:", result.stderr);
  }


  // With streaming
  await sandbox.exec("npm install", {
    stream: true,
    onOutput: (stream, data) => console.log(`[${stream}] ${data}`),
  });


  // With environment variables (undefined values are skipped)
  await sandbox.exec("node app.js", {
    env: {
      NODE_ENV: "production",
      PORT: "3000",
      DEBUG_MODE: undefined, // Skipped, uses container default or unset
    },
  });


  // Pass input via stdin (no shell injection risks)
  const result = await sandbox.exec("cat", {
    stdin: "Hello, world!",
  });
  console.log(result.stdout); // "Hello, world!"


  // Process user input safely
  const userInput = "user@example.com\nsecret123";
  await sandbox.exec("python process_login.py", {
    stdin: userInput,
  });
  ```

* TypeScript

  ```ts
  const result = await sandbox.exec('npm run build');


  if (result.success) {
    console.log('Build output:', result.stdout);
  } else {
    console.error('Build failed:', result.stderr);
  }


  // With streaming
  await sandbox.exec('npm install', {
    stream: true,
    onOutput: (stream, data) => console.log(`[${stream}] ${data}`)
  });


  // With environment variables (undefined values are skipped)
  await sandbox.exec('node app.js', {
    env: {
      NODE_ENV: 'production',
      PORT: '3000',
      DEBUG_MODE: undefined // Skipped, uses container default or unset
    }
  });


  // Pass input via stdin (no shell injection risks)
  const result = await sandbox.exec('cat', {
    stdin: 'Hello, world!'
  });
  console.log(result.stdout); // "Hello, world!"


  // Process user input safely
  const userInput = 'user@example.com\nsecret123';
  await sandbox.exec('python process_login.py', {
    stdin: userInput
  });
  ```

### `execStream()`

Execute a command and return a Server-Sent Events stream for real-time processing.

```ts
const stream = await sandbox.execStream(command: string, options?: ExecOptions): Promise<ReadableStream>
```

**Parameters**:

* `command` - The command to execute
* `options` - Same as `exec()` (including `stdin` support)

**Returns**: `Promise<ReadableStream>` emitting `ExecEvent` objects (`start`, `stdout`, `stderr`, `complete`, `error`)

* JavaScript

  ```js
  import { parseSSEStream } from "@cloudflare/sandbox";


  const stream = await sandbox.execStream("npm run build");


  for await (const event of parseSSEStream(stream)) {
    switch (event.type) {
      case "stdout":
        console.log("Output:", event.data);
        break;
      case "complete":
        console.log("Exit code:", event.exitCode);
        break;
      case "error":
        console.error("Failed:", event.error);
        break;
    }
  }


  // Stream with stdin input
  const inputStream = await sandbox.execStream(
    'python -c "import sys; print(sys.stdin.read())"',
    {
      stdin: "Data from Workers!",
    },
  );


  for await (const event of parseSSEStream(inputStream)) {
    if (event.type === "stdout") {
      console.log("Python received:", event.data);
    }
  }
  ```

* TypeScript

  ```ts
  import { parseSSEStream, type ExecEvent } from '@cloudflare/sandbox';


  const stream = await sandbox.execStream('npm run build');


  for await (const event of parseSSEStream<ExecEvent>(stream)) {
    switch (event.type) {
      case 'stdout':
        console.log('Output:', event.data);
        break;
      case 'complete':
        console.log('Exit code:', event.exitCode);
        break;
      case 'error':
        console.error('Failed:', event.error);
        break;
    }
  }


  // Stream with stdin input
  const inputStream = await sandbox.execStream('python -c "import sys; print(sys.stdin.read())"', {
    stdin: 'Data from Workers!'
  });


  for await (const event of parseSSEStream<ExecEvent>(inputStream)) {
    if (event.type === 'stdout') {
      console.log('Python received:', event.data);
    }
  }
  ```

### `startProcess()`

Start a long-running background process.

```ts
const process = await sandbox.startProcess(command: string, options?: ProcessOptions): Promise<Process>
```

**Parameters**:

* `command` - The command to start as a background process

* `options` (optional):

  * `cwd` - Working directory
  * `env` - Environment variables: `Record<string, string | undefined>`
  * `stdin` - Data to pass to the command's standard input
  * `timeout` - Maximum execution time in milliseconds
  * `processId` - Custom process ID
  * `encoding` - Output encoding (default: `'utf8'`)
  * `autoCleanup` - Whether to clean up process on sandbox sleep

**Returns**: `Promise<Process>` object with:

* `id` - Unique process identifier
* `pid` - System process ID
* `command` - The command being executed
* `status` - Current status (`'running'`, `'exited'`, etc.)
* `kill()` - Stop the process
* `getStatus()` - Get current status
* `getLogs()` - Get accumulated logs
* `waitForPort()` - Wait for process to listen on a port
* `waitForLog()` - Wait for pattern in process output
* `waitForExit()` - Wait for process to terminate and return exit code

- JavaScript

  ```js
  const server = await sandbox.startProcess("python -m http.server 8000");
  console.log("Started with PID:", server.pid);


  // With custom environment
  const app = await sandbox.startProcess("node app.js", {
    cwd: "/workspace/my-app",
    env: { NODE_ENV: "production", PORT: "3000" },
  });


  // Start process with stdin input (useful for interactive applications)
  const interactive = await sandbox.startProcess("python interactive_app.py", {
    stdin: "initial_config\nstart_mode\n",
  });
  ```

- TypeScript

  ```ts
  const server = await sandbox.startProcess('python -m http.server 8000');
  console.log('Started with PID:', server.pid);


  // With custom environment
  const app = await sandbox.startProcess('node app.js', {
    cwd: '/workspace/my-app',
    env: { NODE_ENV: 'production', PORT: '3000' }
  });


  // Start process with stdin input (useful for interactive applications)
  const interactive = await sandbox.startProcess('python interactive_app.py', {
    stdin: 'initial_config\nstart_mode\n'
  });
  ```

### `listProcesses()`

List all running processes.

```ts
const processes = await sandbox.listProcesses(): Promise<ProcessInfo[]>
```

* JavaScript

  ```js
  const processes = await sandbox.listProcesses();


  for (const proc of processes) {
    console.log(`${proc.id}: ${proc.command} (PID ${proc.pid})`);
  }
  ```

* TypeScript

  ```ts
  const processes = await sandbox.listProcesses();


  for (const proc of processes) {
    console.log(`${proc.id}: ${proc.command} (PID ${proc.pid})`);
  }
  ```

### `killProcess()`

Terminate a specific process and all of its child processes.

```ts
await sandbox.killProcess(processId: string, signal?: string): Promise<void>
```

**Parameters**:

* `processId` - The process ID (from `startProcess()` or `listProcesses()`)
* `signal` - Signal to send (default: `"SIGTERM"`)

Sends the signal to the entire process group, ensuring that both the main process and any child processes it spawned are terminated. This prevents orphaned processes from continuing to run after the parent is killed.

* JavaScript

  ```js
  const server = await sandbox.startProcess("python -m http.server 8000");
  await sandbox.killProcess(server.id);


  // Example with a process that spawns children
  const script = await sandbox.startProcess(
    'bash -c "sleep 10 & sleep 10 & wait"',
  );
  // killProcess terminates both sleep commands and the bash process
  await sandbox.killProcess(script.id);
  ```

* TypeScript

  ```ts
  const server = await sandbox.startProcess('python -m http.server 8000');
  await sandbox.killProcess(server.id);


  // Example with a process that spawns children
  const script = await sandbox.startProcess('bash -c "sleep 10 & sleep 10 & wait"');
  // killProcess terminates both sleep commands and the bash process
  await sandbox.killProcess(script.id);
  ```

### `killAllProcesses()`

Terminate all running processes.

```ts
await sandbox.killAllProcesses(): Promise<void>
```

* JavaScript

  ```js
  await sandbox.killAllProcesses();
  ```

* TypeScript

  ```ts
  await sandbox.killAllProcesses();
  ```

### `streamProcessLogs()`

Stream logs from a running process in real-time.

```ts
const stream = await sandbox.streamProcessLogs(processId: string): Promise<ReadableStream>
```

**Parameters**:

* `processId` - The process ID

**Returns**: `Promise<ReadableStream>` emitting `LogEvent` objects

* JavaScript

  ```js
  import { parseSSEStream } from "@cloudflare/sandbox";


  const server = await sandbox.startProcess("node server.js");
  const logStream = await sandbox.streamProcessLogs(server.id);


  for await (const log of parseSSEStream(logStream)) {
    console.log(`[${log.timestamp}] ${log.data}`);


    if (log.data.includes("Server started")) break;
  }
  ```

* TypeScript

  ```ts
  import { parseSSEStream, type LogEvent } from '@cloudflare/sandbox';


  const server = await sandbox.startProcess('node server.js');
  const logStream = await sandbox.streamProcessLogs(server.id);


  for await (const log of parseSSEStream<LogEvent>(logStream)) {
    console.log(`[${log.timestamp}] ${log.data}`);


    if (log.data.includes('Server started')) break;
  }
  ```

### `getProcessLogs()`

Get accumulated logs from a process.

```ts
const logs = await sandbox.getProcessLogs(processId: string): Promise<string>
```

**Parameters**:

* `processId` - The process ID

**Returns**: `Promise<string>` with all accumulated output

* JavaScript

  ```js
  const server = await sandbox.startProcess("node server.js");
  await new Promise((resolve) => setTimeout(resolve, 5000));


  const logs = await sandbox.getProcessLogs(server.id);
  console.log("Server logs:", logs);
  ```

* TypeScript

  ```ts
  const server = await sandbox.startProcess('node server.js');
  await new Promise(resolve => setTimeout(resolve, 5000));


  const logs = await sandbox.getProcessLogs(server.id);
  console.log('Server logs:', logs);
  ```

## Standard input (stdin)

All command execution methods support passing data to a command's standard input via the `stdin` option. This enables secure processing of user input without shell injection risks.

### How stdin works

When you provide the `stdin` option:

1. The input data is written to a temporary file inside the container
2. The command receives this data through its standard input stream
3. The temporary file is automatically cleaned up after execution

This approach prevents shell injection attacks that could occur when embedding user data directly in commands.

* JavaScript

  ```js
  // Safe: User input goes through stdin, not shell parsing
  const userInput = "user@domain.com; rm -rf /";
  const result = await sandbox.exec("python validate_email.py", {
    stdin: userInput,
  });


  // Instead of unsafe: `python validate_email.py "${userInput}"`
  // which could execute the embedded `rm -rf /` command
  ```

* TypeScript

  ```ts
  // Safe: User input goes through stdin, not shell parsing
  const userInput = 'user@domain.com; rm -rf /';
  const result = await sandbox.exec('python validate_email.py', {
    stdin: userInput
  });


  // Instead of unsafe: `python validate_email.py "${userInput}"`
  // which could execute the embedded `rm -rf /` command
  ```

### Common patterns

**Processing form data:**

* JavaScript

  ```js
  const formData = JSON.stringify({
    username: "john_doe",
    email: "john@example.com",
  });


  const result = await sandbox.exec("python process_form.py", {
    stdin: formData,
  });
  ```

* TypeScript

  ```ts
  const formData = JSON.stringify({
    username: 'john_doe',
    email: 'john@example.com'
  });


  const result = await sandbox.exec('python process_form.py', {
    stdin: formData
  });
  ```

**Interactive command-line tools:**

* JavaScript

  ```js
  // Simulate user responses to prompts
  const responses = "yes\nmy-app\n1.0.0\n";
  const result = await sandbox.exec("npm init", {
    stdin: responses,
  });
  ```

* TypeScript

  ```ts
  // Simulate user responses to prompts
  const responses = 'yes\nmy-app\n1.0.0\n';
  const result = await sandbox.exec('npm init', {
    stdin: responses
  });
  ```

**Data transformation:**

* JavaScript

  ```js
  const csvData = "name,age,city\nJohn,30,NYC\nJane,25,LA";
  const result = await sandbox.exec("python csv_processor.py", {
    stdin: csvData,
  });


  console.log("Processed data:", result.stdout);
  ```

* TypeScript

  ```ts
  const csvData = 'name,age,city\nJohn,30,NYC\nJane,25,LA';
  const result = await sandbox.exec('python csv_processor.py', {
    stdin: csvData
  });


  console.log('Processed data:', result.stdout);
  ```

## Process readiness methods

The `Process` object returned by `startProcess()` includes methods to wait for the process to be ready before proceeding.

### `process.waitForPort()`

Wait for a process to listen on a port.

```ts
await process.waitForPort(port: number, options?: WaitForPortOptions): Promise<void>
```

**Parameters**:

* `port` - The port number to check

* `options` (optional):

  * `mode` - Check mode: `'http'` (default) or `'tcp'`
  * `timeout` - Maximum wait time in milliseconds
  * `interval` - Check interval in milliseconds (default: `100`)
  * `path` - HTTP path to check (default: `'/'`, HTTP mode only)
  * `status` - Expected HTTP status range (default: `{ min: 200, max: 399 }`, HTTP mode only)

**HTTP mode** (default) makes an HTTP GET request and checks the response status:

* JavaScript

  ```js
  const server = await sandbox.startProcess("node server.js");


  // Wait for server to be ready (HTTP mode)
  await server.waitForPort(3000);


  // Check specific endpoint and status
  await server.waitForPort(8080, {
    path: "/health",
    status: { min: 200, max: 299 },
    timeout: 30000,
  });
  ```

* TypeScript

  ```ts
  const server = await sandbox.startProcess('node server.js');


  // Wait for server to be ready (HTTP mode)
  await server.waitForPort(3000);


  // Check specific endpoint and status
  await server.waitForPort(8080, {
    path: '/health',
    status: { min: 200, max: 299 },
    timeout: 30000
  });
  ```

**TCP mode** checks if the port accepts connections:

* JavaScript

  ```js
  const db = await sandbox.startProcess("redis-server");


  // Wait for database to accept connections
  await db.waitForPort(6379, {
    mode: "tcp",
    timeout: 10000,
  });
  ```

* TypeScript

  ```ts
  const db = await sandbox.startProcess('redis-server');


  // Wait for database to accept connections
  await db.waitForPort(6379, {
    mode: 'tcp',
    timeout: 10000
  });
  ```

**Throws**:

* `ProcessReadyTimeoutError` - If port does not become ready within timeout
* `ProcessExitedBeforeReadyError` - If process exits before becoming ready

### `process.waitForLog()`

Wait for a pattern to appear in process output.

```ts
const result = await process.waitForLog(pattern: string | RegExp, timeout?: number): Promise<WaitForLogResult>
```

**Parameters**:

* `pattern` - String or RegExp to match in stdout/stderr
* `timeout` - Maximum wait time in milliseconds (optional)

**Returns**: `Promise<WaitForLogResult>` with:

* `line` - The matching line of output
* `matches` - Array of capture groups (for RegExp patterns)

- JavaScript

  ```js
  const server = await sandbox.startProcess("node server.js");


  // Wait for string pattern
  const result = await server.waitForLog("Server listening");
  console.log("Ready:", result.line);


  // Wait for RegExp with capture groups
  const result = await server.waitForLog(/Server listening on port (\d+)/);
  console.log("Port:", result.matches[1]); // Extracted port number


  // With timeout
  await server.waitForLog("Ready", 30000);
  ```

- TypeScript

  ```ts
  const server = await sandbox.startProcess('node server.js');


  // Wait for string pattern
  const result = await server.waitForLog('Server listening');
  console.log('Ready:', result.line);


  // Wait for RegExp with capture groups
  const result = await server.waitForLog(/Server listening on port (\d+)/);
  console.log('Port:', result.matches[1]); // Extracted port number


  // With timeout
  await server.waitForLog('Ready', 30000);
  ```

**Throws**:

* `ProcessReadyTimeoutError` - If pattern is not found within timeout
* `ProcessExitedBeforeReadyError` - If process exits before pattern appears

### `process.waitForExit()`

Wait for a process to terminate and return the exit code.

```ts
const result = await process.waitForExit(timeout?: number): Promise<WaitForExitResult>
```

**Parameters**:

* `timeout` - Maximum wait time in milliseconds (optional)

**Returns**: `Promise<WaitForExitResult>` with:

* `exitCode` - The process exit code

- JavaScript

  ```js
  const build = await sandbox.startProcess("npm run build");


  // Wait for build to complete
  const result = await build.waitForExit();
  console.log("Build finished with exit code:", result.exitCode);


  // With timeout
  const result = await build.waitForExit(60000); // 60 second timeout
  ```

- TypeScript

  ```ts
  const build = await sandbox.startProcess('npm run build');


  // Wait for build to complete
  const result = await build.waitForExit();
  console.log('Build finished with exit code:', result.exitCode);


  // With timeout
  const result = await build.waitForExit(60000); // 60 second timeout
  ```

**Throws**:

* `ProcessReadyTimeoutError` - If process does not exit within timeout

## Related resources

* [Background processes guide](https://developers.cloudflare.com/sandbox/guides/background-processes/) - Managing long-running processes
* [Files API](https://developers.cloudflare.com/sandbox/api/files/) - File operations

</page>

<page>
---
title: File Watching · Cloudflare Sandbox SDK docs
description: Monitor filesystem changes in real-time using Linux's native
  inotify system. The file watching API provides efficient monitoring of files
  and directories with support for filtering, exclusions, and callback-based
  event handling.
lastUpdated: 2026-02-06T17:10:29.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/api/file-watching/
  md: https://developers.cloudflare.com/sandbox/api/file-watching/index.md
---

Monitor filesystem changes in real-time using Linux's native inotify system. The file watching API provides efficient monitoring of files and directories with support for filtering, exclusions, and callback-based event handling.

## Methods

### `watch()`

Watch a directory for filesystem changes in real-time.

```ts
await sandbox.watch(path: string, options?: WatchOptions): Promise<WatchHandle>
```

**Parameters**:

* `path` - Absolute path or relative to `/workspace` (e.g., `/app/src` or `src`)

* `options` (optional):

  * `recursive` - Watch subdirectories recursively (default: `true`)
  * `include` - Glob patterns to include (e.g., `['*.ts', '*.js']`)
  * `exclude` - Glob patterns to exclude (default: `['.git', 'node_modules', '.DS_Store']`)
  * `signal` - AbortSignal to cancel the watch
  * `onEvent` - Callback for file change events
  * `onError` - Callback for watch errors

**Returns**: `WatchHandle` with `stop()` method and metadata properties

* JavaScript

  ```js
  // Watch entire project directory
  const watcher = await sandbox.watch("/workspace", {
    onEvent: (event) => {
      console.log(`${event.type}: ${event.path}`);
      console.log(`Is directory: ${event.isDirectory}`);
    },
    onError: (error) => {
      console.error("Watch error:", error.message);
    },
  });


  // Stop watching when done
  await watcher.stop();
  ```

* TypeScript

  ```ts
  // Watch entire project directory
  const watcher = await sandbox.watch('/workspace', {
    onEvent: (event) => {
      console.log(`${event.type}: ${event.path}`);
      console.log(`Is directory: ${event.isDirectory}`);
    },
    onError: (error) => {
      console.error('Watch error:', error.message);
    }
  });


  // Stop watching when done
  await watcher.stop();
  ```

- JavaScript

  ```js
  // Watch specific file types in a directory
  const watcher = await sandbox.watch("/workspace/src", {
    include: ["*.ts", "*.tsx"],
    exclude: ["*.test.ts", "dist"],
    onEvent: (event) => {
      if (event.type === "modify") {
        console.log(`TypeScript file modified: ${event.path}`);
      }
    },
  });
  ```

- TypeScript

  ```ts
  // Watch specific file types in a directory
  const watcher = await sandbox.watch('/workspace/src', {
    include: ['*.ts', '*.tsx'],
    exclude: ['*.test.ts', 'dist'],
    onEvent: (event) => {
      if (event.type === 'modify') {
        console.log(`TypeScript file modified: ${event.path}`);
      }
    }
  });
  ```

### `watchStream()`

Get raw SSE stream for file watching (advanced usage).

```ts
const stream = await sandbox.watchStream(path: string, options?: WatchRequest): Promise<ReadableStream<Uint8Array>>
```

Most users should use `watch()` instead, which provides a higher-level API with proper lifecycle management.

### `stopWatch()`

Stop a specific watch by ID.

```ts
await sandbox.stopWatch(watchId: string): Promise<{ success: boolean }>
```

**Parameters**:

* `watchId` - Watch ID from the WatchHandle

### `listWatches()`

List all active watches.

```ts
const result = await sandbox.listWatches(): Promise<WatchListResult>
```

**Returns**:

```ts
interface WatchListResult {
  success: boolean;
  watches: Array<{
    id: string;
    path: string;
    startedAt: string;
  }>;
  count: number;
  timestamp: string;
}
```

## Types

### `WatchHandle`

Handle returned from `watch()` to control and inspect the watch.

```ts
interface WatchHandle {
  /** Stop watching and clean up resources */
  stop(): Promise<void>;
  /** The watch ID (for debugging) */
  readonly id: string;
  /** The path being watched */
  readonly path: string;
}
```

### `WatchEvent`

File system change event passed to the `onEvent` callback.

```ts
interface WatchEvent {
  /** The type of change that occurred */
  type: WatchEventType;
  /** Absolute path to the file or directory that changed */
  path: string;
  /** Whether the changed path is a directory */
  isDirectory: boolean;
}
```

### `WatchEventType`

Types of filesystem changes that can be detected.

```ts
type WatchEventType = "create" | "modify" | "delete" | "rename";
```

* **`create`** - File or directory was created
* **`modify`** - File content or directory attributes changed
* **`delete`** - File or directory was deleted
* **`rename`** - File or directory was moved/renamed

### `WatchOptions`

Configuration options for watching directories.

```ts
interface WatchOptions {
  /** Watch subdirectories recursively (default: true) */
  recursive?: boolean;
  /** Glob patterns to include (e.g., ['*.ts', '*.js']) */
  include?: string[];
  /** Glob patterns to exclude (default: ['.git', 'node_modules', '.DS_Store']) */
  exclude?: string[];
  /** AbortSignal to cancel the watch */
  signal?: AbortSignal;
  /** Callback for file change events */
  onEvent?: (event: WatchEvent) => void;
  /** Callback for errors (e.g., watch process died) */
  onError?: (error: Error) => void;
}
```

## Notes

Container lifecycle

File watchers are automatically stopped when the sandbox container sleeps or is destroyed. You do not need to manually stop them on container shutdown.

Path requirements

All paths must exist when starting a watch. Watching non-existent paths returns an error. Create directories before watching them.

## Related resources

* [Watch filesystem changes guide](https://developers.cloudflare.com/sandbox/guides/file-watching/) - Patterns, best practices, and real-world examples

</page>

<page>
---
title: Files · Cloudflare Sandbox SDK docs
description: Read, write, and manage files in the sandbox filesystem. All paths
  are absolute (e.g., /workspace/app.js).
lastUpdated: 2026-02-06T16:47:49.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/api/files/
  md: https://developers.cloudflare.com/sandbox/api/files/index.md
---

Read, write, and manage files in the sandbox filesystem. All paths are absolute (e.g., `/workspace/app.js`).

## Methods

### `writeFile()`

Write content to a file.

```ts
await sandbox.writeFile(path: string, content: string, options?: WriteFileOptions): Promise<void>
```

**Parameters**:

* `path` - Absolute path to the file
* `content` - Content to write
* `options` (optional):
  * `encoding` - File encoding (`"utf-8"` or `"base64"`, default: `"utf-8"`)

- JavaScript

  ```js
  await sandbox.writeFile("/workspace/app.js", `console.log('Hello!');`);


  // Binary data
  await sandbox.writeFile("/tmp/image.png", base64Data, { encoding: "base64" });
  ```

- TypeScript

  ```ts
  await sandbox.writeFile('/workspace/app.js', `console.log('Hello!');`);


  // Binary data
  await sandbox.writeFile('/tmp/image.png', base64Data, { encoding: 'base64' });
  ```

Base64 validation

When using `encoding: 'base64'`, content must contain only valid base64 characters (A-Z, a-z, 0-9, +, /, =). Invalid base64 content returns a validation error.

### `readFile()`

Read a file from the sandbox.

```ts
const file = await sandbox.readFile(path: string, options?: ReadFileOptions): Promise<FileInfo>
```

**Parameters**:

* `path` - Absolute path to the file
* `options` (optional):
  * `encoding` - File encoding (`"utf-8"` or `"base64"`, default: auto-detected from MIME type)

**Returns**: `Promise<FileInfo>` with `content` and `encoding`

* JavaScript

  ```js
  const file = await sandbox.readFile("/workspace/package.json");
  const pkg = JSON.parse(file.content);


  // Binary data (auto-detected or forced)
  const image = await sandbox.readFile("/tmp/image.png", { encoding: "base64" });


  // Force encoding (override MIME detection)
  const textAsBase64 = await sandbox.readFile("/workspace/data.txt", {
    encoding: "base64",
  });
  ```

* TypeScript

  ```ts
  const file = await sandbox.readFile('/workspace/package.json');
  const pkg = JSON.parse(file.content);


  // Binary data (auto-detected or forced)
  const image = await sandbox.readFile('/tmp/image.png', { encoding: 'base64' });


  // Force encoding (override MIME detection)
  const textAsBase64 = await sandbox.readFile('/workspace/data.txt', { encoding: 'base64' });
  ```

Encoding behavior

When `encoding` is specified, it overrides MIME-based auto-detection. Without `encoding`, the SDK detects the appropriate encoding from the file's MIME type.

### `exists()`

Check if a file or directory exists.

```ts
const result = await sandbox.exists(path: string): Promise<FileExistsResult>
```

**Parameters**:

* `path` - Absolute path to check

**Returns**: `Promise<FileExistsResult>` with `exists` boolean

* JavaScript

  ```js
  const result = await sandbox.exists("/workspace/package.json");
  if (result.exists) {
    const file = await sandbox.readFile("/workspace/package.json");
    // process file
  }


  // Check directory
  const dirResult = await sandbox.exists("/workspace/src");
  if (!dirResult.exists) {
    await sandbox.mkdir("/workspace/src");
  }
  ```

* TypeScript

  ```ts
  const result = await sandbox.exists('/workspace/package.json');
  if (result.exists) {
    const file = await sandbox.readFile('/workspace/package.json');
    // process file
  }


  // Check directory
  const dirResult = await sandbox.exists('/workspace/src');
  if (!dirResult.exists) {
    await sandbox.mkdir('/workspace/src');
  }
  ```

Available on sessions

Both `sandbox.exists()` and `session.exists()` are supported.

### `mkdir()`

Create a directory.

```ts
await sandbox.mkdir(path: string, options?: MkdirOptions): Promise<void>
```

**Parameters**:

* `path` - Absolute path to the directory
* `options` (optional):
  * `recursive` - Create parent directories if needed (default: `false`)

- JavaScript

  ```js
  await sandbox.mkdir("/workspace/src");


  // Nested directories
  await sandbox.mkdir("/workspace/src/components/ui", { recursive: true });
  ```

- TypeScript

  ```ts
  await sandbox.mkdir('/workspace/src');


  // Nested directories
  await sandbox.mkdir('/workspace/src/components/ui', { recursive: true });
  ```

### `deleteFile()`

Delete a file.

```ts
await sandbox.deleteFile(path: string): Promise<void>
```

**Parameters**:

* `path` - Absolute path to the file

- JavaScript

  ```js
  await sandbox.deleteFile("/workspace/temp.txt");
  ```

- TypeScript

  ```ts
  await sandbox.deleteFile('/workspace/temp.txt');
  ```

### `renameFile()`

Rename a file.

```ts
await sandbox.renameFile(oldPath: string, newPath: string): Promise<void>
```

**Parameters**:

* `oldPath` - Current file path
* `newPath` - New file path

- JavaScript

  ```js
  await sandbox.renameFile("/workspace/draft.txt", "/workspace/final.txt");
  ```

- TypeScript

  ```ts
  await sandbox.renameFile('/workspace/draft.txt', '/workspace/final.txt');
  ```

### `moveFile()`

Move a file to a different directory.

```ts
await sandbox.moveFile(sourcePath: string, destinationPath: string): Promise<void>
```

**Parameters**:

* `sourcePath` - Current file path
* `destinationPath` - Destination path

- JavaScript

  ```js
  await sandbox.moveFile("/tmp/download.txt", "/workspace/data.txt");
  ```

- TypeScript

  ```ts
  await sandbox.moveFile('/tmp/download.txt', '/workspace/data.txt');
  ```

### `gitCheckout()`

Clone a git repository.

```ts
await sandbox.gitCheckout(repoUrl: string, options?: GitCheckoutOptions): Promise<void>
```

**Parameters**:

* `repoUrl` - Git repository URL

* `options` (optional):

  * `branch` - Branch to checkout (default: repository default branch)
  * `targetDir` - Directory to clone into (default: `/workspace/{repoName}`)
  * `depth` - Clone depth for shallow clones (e.g., `1` for latest commit only)

- JavaScript

  ```js
  await sandbox.gitCheckout("https://github.com/user/repo");


  // Specific branch
  await sandbox.gitCheckout("https://github.com/user/repo", {
    branch: "develop",
    targetDir: "/workspace/my-project",
  });


  // Shallow clone (faster for large repositories)
  await sandbox.gitCheckout("https://github.com/facebook/react", {
    depth: 1,
  });
  ```

- TypeScript

  ```ts
  await sandbox.gitCheckout('https://github.com/user/repo');


  // Specific branch
  await sandbox.gitCheckout('https://github.com/user/repo', {
    branch: 'develop',
    targetDir: '/workspace/my-project'
  });


  // Shallow clone (faster for large repositories)
  await sandbox.gitCheckout('https://github.com/facebook/react', {
    depth: 1
  });
  ```

## Related resources

* [Manage files guide](https://developers.cloudflare.com/sandbox/guides/manage-files/) - Detailed guide with best practices
* [Commands API](https://developers.cloudflare.com/sandbox/api/commands/) - Execute commands

</page>

<page>
---
title: Code Interpreter · Cloudflare Sandbox SDK docs
description: Execute Python, JavaScript, and TypeScript code with support for
  data visualizations, tables, and rich output formats. Contexts maintain state
  (variables, imports, functions) across executions.
lastUpdated: 2026-01-28T11:00:00.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/api/interpreter/
  md: https://developers.cloudflare.com/sandbox/api/interpreter/index.md
---

Execute Python, JavaScript, and TypeScript code with support for data visualizations, tables, and rich output formats. Contexts maintain state (variables, imports, functions) across executions.

## Methods

### `createCodeContext()`

Create a persistent execution context for running code.

```ts
const context = await sandbox.createCodeContext(options?: CreateContextOptions): Promise<CodeContext>
```

**Parameters**:

* `options` (optional):

  * `language` - `"python" | "javascript" | "typescript"` (default: `"python"`)
  * `cwd` - Working directory (default: `"/workspace"`)
  * `envVars` - Environment variables
  * `timeout` - Request timeout in milliseconds (default: 30000)

**Returns**: `Promise<CodeContext>` with `id`, `language`, `cwd`, `createdAt`, `lastUsed`

* JavaScript

  ```js
  const ctx = await sandbox.createCodeContext({
    language: "python",
    envVars: { API_KEY: env.API_KEY },
  });
  ```

* TypeScript

  ```ts
  const ctx = await sandbox.createCodeContext({
    language: 'python',
    envVars: { API_KEY: env.API_KEY }
  });
  ```

### `runCode()`

Execute code in a context and return the complete result.

```ts
const result = await sandbox.runCode(code: string, options?: RunCodeOptions): Promise<ExecutionResult>
```

**Parameters**:

* `code` - The code to execute (required)

* `options` (optional):

  * `context` - Context to run in (recommended - see below)
  * `language` - `"python" | "javascript" | "typescript"` (default: `"python"`)
  * `timeout` - Execution timeout in milliseconds (default: 60000)
  * `onStdout`, `onStderr`, `onResult`, `onError` - Streaming callbacks

**Returns**: `Promise<ExecutionResult>` with:

* `code` - The executed code
* `logs` - `stdout` and `stderr` arrays
* `results` - Array of rich outputs (see [Rich Output Formats](#rich-output-formats))
* `error` - Execution error if any
* `executionCount` - Execution counter

**Recommended usage - create explicit context**:

* JavaScript

  ```js
  const ctx = await sandbox.createCodeContext({ language: "python" });


  await sandbox.runCode("import math; radius = 5", { context: ctx });
  const result = await sandbox.runCode("math.pi * radius ** 2", { context: ctx });


  console.log(result.results[0].text); // "78.53981633974483"
  ```

* TypeScript

  ```ts
  const ctx = await sandbox.createCodeContext({ language: 'python' });


  await sandbox.runCode('import math; radius = 5', { context: ctx });
  const result = await sandbox.runCode('math.pi * radius ** 2', { context: ctx });


  console.log(result.results[0].text); // "78.53981633974483"
  ```

Default context behavior

If no `context` is provided, a default context is automatically created/reused for the specified `language`. While convenient for quick tests, **explicitly creating contexts is recommended** for production use to maintain predictable state.

* JavaScript

  ```js
  const result = await sandbox.runCode(
    `
  data = [1, 2, 3, 4, 5]
  print(f"Sum: {sum(data)}")
  sum(data)
  `,
    { language: "python" },
  );


  console.log(result.logs.stdout); // ["Sum: 15"]
  console.log(result.results[0].text); // "15"
  ```

* TypeScript

  ```ts
  const result = await sandbox.runCode(`
  data = [1, 2, 3, 4, 5]
  print(f"Sum: {sum(data)}")
  sum(data)
  `, { language: 'python' });


  console.log(result.logs.stdout); // ["Sum: 15"]
  console.log(result.results[0].text); // "15"
  ```

**Error handling**:

* JavaScript

  ```js
  const result = await sandbox.runCode("x = 1 / 0", { language: "python" });


  if (result.error) {
    console.error(result.error.name); // "ZeroDivisionError"
    console.error(result.error.value); // "division by zero"
    console.error(result.error.traceback); // Stack trace array
  }
  ```

* TypeScript

  ```ts
  const result = await sandbox.runCode('x = 1 / 0', { language: 'python' });


  if (result.error) {
    console.error(result.error.name);      // "ZeroDivisionError"
    console.error(result.error.value);     // "division by zero"
    console.error(result.error.traceback); // Stack trace array
  }
  ```

**JavaScript and TypeScript features**:

JavaScript and TypeScript code execution supports top-level `await` and persistent variables across executions within the same context.

* JavaScript

  ```js
  const ctx = await sandbox.createCodeContext({ language: "javascript" });


  // Execution 1: Fetch data with top-level await
  await sandbox.runCode(
    `
  const response = await fetch('https://api.example.com/data');
  const data = await response.json();
  `,
    { context: ctx },
  );


  // Execution 2: Use the data from previous execution
  const result = await sandbox.runCode("console.log(data)", { context: ctx });
  console.log(result.logs.stdout); // Data persists across executions
  ```

* TypeScript

  ```ts
  const ctx = await sandbox.createCodeContext({ language: 'javascript' });


  // Execution 1: Fetch data with top-level await
  await sandbox.runCode(`
  const response = await fetch('https://api.example.com/data');
  const data = await response.json();
  `, { context: ctx });


  // Execution 2: Use the data from previous execution
  const result = await sandbox.runCode('console.log(data)', { context: ctx });
  console.log(result.logs.stdout); // Data persists across executions
  ```

Variables declared with `const`, `let`, or `var` persist across executions, enabling multi-step workflows:

* JavaScript

  ```js
  const ctx = await sandbox.createCodeContext({ language: "javascript" });


  await sandbox.runCode("const x = 10", { context: ctx });
  await sandbox.runCode("let y = 20", { context: ctx });
  const result = await sandbox.runCode("x + y", { context: ctx });


  console.log(result.results[0].text); // "30"
  ```

* TypeScript

  ```ts
  const ctx = await sandbox.createCodeContext({ language: 'javascript' });


  await sandbox.runCode('const x = 10', { context: ctx });
  await sandbox.runCode('let y = 20', { context: ctx });
  const result = await sandbox.runCode('x + y', { context: ctx });


  console.log(result.results[0].text); // "30"
  ```

### `listCodeContexts()`

List all active code execution contexts.

```ts
const contexts = await sandbox.listCodeContexts(): Promise<CodeContext[]>
```

* JavaScript

  ```js
  const contexts = await sandbox.listCodeContexts();
  console.log(`Found ${contexts.length} contexts`);
  ```

* TypeScript

  ```ts
  const contexts = await sandbox.listCodeContexts();
  console.log(`Found ${contexts.length} contexts`);
  ```

### `deleteCodeContext()`

Delete a code execution context and free its resources.

```ts
await sandbox.deleteCodeContext(contextId: string): Promise<void>
```

* JavaScript

  ```js
  const ctx = await sandbox.createCodeContext({ language: "python" });
  await sandbox.runCode('print("Hello")', { context: ctx });
  await sandbox.deleteCodeContext(ctx.id);
  ```

* TypeScript

  ```ts
  const ctx = await sandbox.createCodeContext({ language: 'python' });
  await sandbox.runCode('print("Hello")', { context: ctx });
  await sandbox.deleteCodeContext(ctx.id);
  ```

## Rich Output Formats

Results include: `text`, `html`, `png`, `jpeg`, `svg`, `latex`, `markdown`, `json`, `chart`, `data`

**Charts (matplotlib)**:

* JavaScript

  ```js
  const result = await sandbox.runCode(
    `
  import matplotlib.pyplot as plt
  import numpy as np


  x = np.linspace(0, 10, 100)
  plt.plot(x, np.sin(x))
  plt.show()
  `,
    { language: "python" },
  );


  if (result.results[0]?.png) {
    const imageBuffer = Buffer.from(result.results[0].png, "base64");
    return new Response(imageBuffer, {
      headers: { "Content-Type": "image/png" },
    });
  }
  ```

* TypeScript

  ```ts
  const result = await sandbox.runCode(`
  import matplotlib.pyplot as plt
  import numpy as np


  x = np.linspace(0, 10, 100)
  plt.plot(x, np.sin(x))
  plt.show()
  `, { language: 'python' });


  if (result.results[0]?.png) {
    const imageBuffer = Buffer.from(result.results[0].png, 'base64');
    return new Response(imageBuffer, {
      headers: { 'Content-Type': 'image/png' }
    });
  }
  ```

**Tables (pandas)**:

* JavaScript

  ```js
  const result = await sandbox.runCode(
    `
  import pandas as pd
  df = pd.DataFrame({'Name': ['Alice', 'Bob'], 'Age': [25, 30]})
  df
  `,
    { language: "python" },
  );


  if (result.results[0]?.html) {
    return new Response(result.results[0].html, {
      headers: { "Content-Type": "text/html" },
    });
  }
  ```

* TypeScript

  ```ts
  const result = await sandbox.runCode(`
  import pandas as pd
  df = pd.DataFrame({'Name': ['Alice', 'Bob'], 'Age': [25, 30]})
  df
  `, { language: 'python' });


  if (result.results[0]?.html) {
    return new Response(result.results[0].html, {
      headers: { 'Content-Type': 'text/html' }
    });
  }
  ```

## Related resources

* [Build an AI Code Executor](https://developers.cloudflare.com/sandbox/tutorials/ai-code-executor/) - Complete tutorial
* [Commands API](https://developers.cloudflare.com/sandbox/api/commands/) - Lower-level command execution
* [Files API](https://developers.cloudflare.com/sandbox/api/files/) - File operations

</page>

<page>
---
title: Lifecycle · Cloudflare Sandbox SDK docs
description: Create and manage sandbox containers. Get sandbox instances,
  configure options, and clean up resources.
lastUpdated: 2026-02-06T17:12:02.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/api/lifecycle/
  md: https://developers.cloudflare.com/sandbox/api/lifecycle/index.md
---

Create and manage sandbox containers. Get sandbox instances, configure options, and clean up resources.

## Methods

### `getSandbox()`

Get or create a sandbox instance by ID.

```ts
const sandbox = getSandbox(
  binding: DurableObjectNamespace<Sandbox>,
  sandboxId: string,
  options?: SandboxOptions
): Sandbox
```

**Parameters**:

* `binding` - The Durable Object namespace binding from your Worker environment

* `sandboxId` - Unique identifier for this sandbox. The same ID always returns the same sandbox instance

* `options` (optional) - See [SandboxOptions](https://developers.cloudflare.com/sandbox/configuration/sandbox-options/) for all available options:

  * `sleepAfter` - Duration of inactivity before automatic sleep (default: `"10m"`)
  * `keepAlive` - Prevent automatic sleep entirely. Persists across hibernation (default: `false`)
  * `containerTimeouts` - Configure container startup timeouts
  * `normalizeId` - Lowercase sandbox IDs for preview URL compatibility (default: `false`)

**Returns**: `Sandbox` instance

Note

The container starts lazily on first operation. Calling `getSandbox()` returns immediately—the container only spins up when you execute a command, write a file, or perform other operations. See [Sandbox lifecycle](https://developers.cloudflare.com/sandbox/concepts/sandboxes/) for details.

* JavaScript

  ```js
  import { getSandbox } from "@cloudflare/sandbox";


  export default {
    async fetch(request, env) {
      const sandbox = getSandbox(env.Sandbox, "user-123");
      const result = await sandbox.exec("python script.py");
      return Response.json(result);
    },
  };
  ```

* TypeScript

  ```ts
  import { getSandbox } from '@cloudflare/sandbox';


  export default {
    async fetch(request: Request, env: Env): Promise<Response> {
      const sandbox = getSandbox(env.Sandbox, 'user-123');
      const result = await sandbox.exec('python script.py');
      return Response.json(result);
    }
  };
  ```

Warning

When using `keepAlive: true`, you **must** call `destroy()` when finished to prevent containers running indefinitely.

***

### `setKeepAlive()`

Enable or disable keepAlive mode dynamically after sandbox creation.

```ts
await sandbox.setKeepAlive(keepAlive: boolean): Promise<void>
```

**Parameters**:

* `keepAlive` - `true` to prevent automatic sleep, `false` to allow normal sleep behavior

When enabled, the sandbox automatically sends heartbeat pings every 30 seconds to prevent container eviction. When disabled, the sandbox returns to normal sleep behavior based on the `sleepAfter` configuration.

* JavaScript

  ```js
  const sandbox = getSandbox(env.Sandbox, "user-123");


  // Enable keepAlive for a long-running process
  await sandbox.setKeepAlive(true);
  await sandbox.startProcess("python long_running_analysis.py");


  // Later, disable keepAlive when done
  await sandbox.setKeepAlive(false);
  ```

* TypeScript

  ```ts
  const sandbox = getSandbox(env.Sandbox, 'user-123');


  // Enable keepAlive for a long-running process
  await sandbox.setKeepAlive(true);
  await sandbox.startProcess('python long_running_analysis.py');


  // Later, disable keepAlive when done
  await sandbox.setKeepAlive(false);
  ```

Heartbeat mechanism

When keepAlive is enabled, the sandbox automatically sends lightweight ping requests to the container every 30 seconds to prevent eviction. This happens transparently without affecting your application code.

Resource management

Containers with `keepAlive: true` will not automatically timeout. Always disable keepAlive or call `destroy()` when done to prevent containers running indefinitely.

***

### `destroy()`

Destroy the sandbox container and free up resources.

```ts
await sandbox.destroy(): Promise<void>
```

Immediately terminates the container and permanently deletes all state:

* All files in `/workspace`, `/tmp`, and `/home`
* All running processes
* All sessions (including the default session)
* Network connections and exposed ports

- JavaScript

  ```js
  async function executeCode(code) {
    const sandbox = getSandbox(env.Sandbox, `temp-${Date.now()}`);


    try {
      await sandbox.writeFile("/tmp/code.py", code);
      const result = await sandbox.exec("python /tmp/code.py");
      return result.stdout;
    } finally {
      await sandbox.destroy();
    }
  }
  ```

- TypeScript

  ```ts
  async function executeCode(code: string): Promise<string> {
    const sandbox = getSandbox(env.Sandbox, `temp-${Date.now()}`);


    try {
      await sandbox.writeFile('/tmp/code.py', code);
      const result = await sandbox.exec('python /tmp/code.py');
      return result.stdout;
    } finally {
      await sandbox.destroy();
    }
  }
  ```

Note

Containers automatically sleep after 10 minutes of inactivity but still count toward account limits. Use `destroy()` to immediately free up resources.

***

## Related resources

* [Sandbox lifecycle concept](https://developers.cloudflare.com/sandbox/concepts/sandboxes/) - Understanding container lifecycle and state
* [Sandbox options configuration](https://developers.cloudflare.com/sandbox/configuration/sandbox-options/) - Configure `keepAlive` and other options
* [Sessions API](https://developers.cloudflare.com/sandbox/api/sessions/) - Create isolated execution contexts within a sandbox

</page>

<page>
---
title: Ports · Cloudflare Sandbox SDK docs
description: Expose services running in your sandbox via public preview URLs.
  See Preview URLs concept for details.
lastUpdated: 2026-02-08T17:19:50.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/api/ports/
  md: https://developers.cloudflare.com/sandbox/api/ports/index.md
---

Production requires custom domain

Preview URLs require a custom domain with wildcard DNS routing in production. See [Production Deployment](https://developers.cloudflare.com/sandbox/guides/production-deployment/).

Expose services running in your sandbox via public preview URLs. See [Preview URLs concept](https://developers.cloudflare.com/sandbox/concepts/preview-urls/) for details.

## Methods

### `exposePort()`

Expose a port and get a preview URL for accessing services running in the sandbox.

```ts
const response = await sandbox.exposePort(port: number, options: ExposePortOptions): Promise<ExposePortResponse>
```

**Parameters**:

* `port` - Port number to expose (1024-65535)

* `options`:

  * `hostname` - Your Worker's domain name (e.g., `'example.com'`). Required to construct preview URLs with wildcard subdomains like `https://8080-sandbox-abc123token.example.com`. Cannot be a `.workers.dev` domain as it doesn't support wildcard DNS patterns.
  * `name` - Friendly name for the port (optional)
  * `token` - Custom token for the preview URL (optional). Must be 1-16 characters containing only lowercase letters (a-z), numbers (0-9), hyphens (-), and underscores (\_). If not provided, a random 16-character token is generated automatically.

**Returns**: `Promise<ExposePortResponse>` with `port`, `url` (preview URL), `name`

* JavaScript

  ```js
  // Extract hostname from request
  const { hostname } = new URL(request.url);


  // Basic usage with auto-generated token
  await sandbox.startProcess("python -m http.server 8000");
  const exposed = await sandbox.exposePort(8000, { hostname });


  console.log("Available at:", exposed.url);
  // https://8000-sandbox-id-abc123random.yourdomain.com


  // With custom token for stable URLs across restarts
  const stable = await sandbox.exposePort(8080, {
    hostname,
    token: "my_service_v1", // 1-16 chars: a-z, 0-9, _
  });
  console.log("Stable URL:", stable.url);
  // https://8080-sandbox-id-my_service_v1.yourdomain.com


  // With custom token for stable URLs across deployments
  await sandbox.startProcess("node api.js");
  const api = await sandbox.exposePort(3000, {
    hostname,
    name: "api",
    token: "prod-api-v1", // URL stays same across restarts
  });


  console.log("Stable API URL:", api.url);
  // https://3000-sandbox-id-prod-api-v1.yourdomain.com


  // Multiple services with custom tokens
  await sandbox.startProcess("npm run dev");
  const frontend = await sandbox.exposePort(5173, {
    hostname,
    name: "frontend",
    token: "dev-ui",
  });
  ```

* TypeScript

  ```ts
  // Extract hostname from request
  const { hostname } = new URL(request.url);


  // Basic usage with auto-generated token
  await sandbox.startProcess('python -m http.server 8000');
  const exposed = await sandbox.exposePort(8000, { hostname });


  console.log('Available at:', exposed.url);
  // https://8000-sandbox-id-abc123random.yourdomain.com


  // With custom token for stable URLs across restarts
  const stable = await sandbox.exposePort(8080, {
    hostname,
    token: 'my_service_v1' // 1-16 chars: a-z, 0-9, _
  });
  console.log('Stable URL:', stable.url);
  // https://8080-sandbox-id-my_service_v1.yourdomain.com


  // With custom token for stable URLs across deployments
  await sandbox.startProcess('node api.js');
  const api = await sandbox.exposePort(3000, {
    hostname,
    name: 'api',
    token: 'prod-api-v1'  // URL stays same across restarts
  });


  console.log('Stable API URL:', api.url);
  // https://3000-sandbox-id-prod-api-v1.yourdomain.com


  // Multiple services with custom tokens
  await sandbox.startProcess('npm run dev');
  const frontend = await sandbox.exposePort(5173, {
    hostname,
    name: 'frontend',
    token: 'dev-ui'
  });
  ```

Local development

When using `wrangler dev`, you must add `EXPOSE` directives to your Dockerfile for each port. See [Expose Services guide](https://developers.cloudflare.com/sandbox/guides/expose-services/#local-development) for details.

## Custom Tokens for Stable URLs

Custom tokens enable consistent preview URLs across container restarts and deployments. This is useful for:

* **Production environments** - Share stable URLs with users or teams
* **Development workflows** - Maintain bookmarks and integrations
* **CI/CD pipelines** - Reference consistent URLs in tests or deployment scripts

**Token Requirements:**

* 1-16 characters in length
* Only lowercase letters (a-z), numbers (0-9), hyphens (-), and underscores (\_)
* Must be unique per sandbox (cannot reuse tokens across different ports)

- JavaScript

  ```js
  // Production API with stable URL
  const { url } = await sandbox.exposePort(8080, {
    hostname: "api.example.com",
    token: "v1-stable", // Always the same URL
  });


  // Error: Token collision prevention
  await sandbox.exposePort(8081, { hostname, token: "v1-stable" });
  // Throws: Token 'v1-stable' is already in use by port 8080


  // Success: Re-exposing same port with same token (idempotent)
  await sandbox.exposePort(8080, { hostname, token: "v1-stable" });
  // Works - same port, same token
  ```

- TypeScript

  ```ts
  // Production API with stable URL
  const { url } = await sandbox.exposePort(8080, {
    hostname: 'api.example.com',
    token: 'v1-stable'  // Always the same URL
  });


  // Error: Token collision prevention
  await sandbox.exposePort(8081, { hostname, token: 'v1-stable' });
  // Throws: Token 'v1-stable' is already in use by port 8080


  // Success: Re-exposing same port with same token (idempotent)
  await sandbox.exposePort(8080, { hostname, token: 'v1-stable' });
  // Works - same port, same token
  ```

### `validatePortToken()`

Validate if a token is authorized to access a specific exposed port. Useful for custom authentication or routing logic.

```ts
const isValid = await sandbox.validatePortToken(port: number, token: string): Promise<boolean>
```

**Parameters**:

* `port` - Port number to check
* `token` - Token to validate

**Returns**: `Promise<boolean>` - `true` if token is valid for the port, `false` otherwise

* JavaScript

  ```js
  // Custom validation in your Worker
  export default {
    async fetch(request, env) {
      const url = new URL(request.url);


      // Extract token from custom header or query param
      const customToken = request.headers.get("x-access-token");


      if (customToken) {
        const sandbox = getSandbox(env.Sandbox, "my-sandbox");
        const isValid = await sandbox.validatePortToken(8080, customToken);


        if (!isValid) {
          return new Response("Invalid token", { status: 403 });
        }
      }


      // Handle preview URL routing
      const proxyResponse = await proxyToSandbox(request, env);
      if (proxyResponse) return proxyResponse;


      // Your application routes
      return new Response("Not found", { status: 404 });
    },
  };
  ```

* TypeScript

  ```ts
  // Custom validation in your Worker
  export default {
    async fetch(request: Request, env: Env): Promise<Response> {
      const url = new URL(request.url);


      // Extract token from custom header or query param
      const customToken = request.headers.get('x-access-token');


      if (customToken) {
        const sandbox = getSandbox(env.Sandbox, 'my-sandbox');
        const isValid = await sandbox.validatePortToken(8080, customToken);


        if (!isValid) {
          return new Response('Invalid token', { status: 403 });
        }
      }


      // Handle preview URL routing
      const proxyResponse = await proxyToSandbox(request, env);
      if (proxyResponse) return proxyResponse;


      // Your application routes
      return new Response('Not found', { status: 404 });
    }
  };
  ```

### `unexposePort()`

Remove an exposed port and close its preview URL.

```ts
await sandbox.unexposePort(port: number): Promise<void>
```

**Parameters**:

* `port` - Port number to unexpose

- JavaScript

  ```js
  await sandbox.unexposePort(8000);
  ```

- TypeScript

  ```ts
  await sandbox.unexposePort(8000);
  ```

### `getExposedPorts()`

Get information about all currently exposed ports.

```ts
const response = await sandbox.getExposedPorts(): Promise<GetExposedPortsResponse>
```

**Returns**: `Promise<GetExposedPortsResponse>` with `ports` array (containing `port`, `exposedAt`, `name`)

* JavaScript

  ```js
  const { ports } = await sandbox.getExposedPorts();


  for (const port of ports) {
    console.log(`${port.name || port.port}: ${port.exposedAt}`);
  }
  ```

* TypeScript

  ```ts
  const { ports } = await sandbox.getExposedPorts();


  for (const port of ports) {
    console.log(`${port.name || port.port}: ${port.exposedAt}`);
  }
  ```

### `wsConnect()`

Connect to WebSocket servers running in the sandbox. Use this when your Worker needs to establish WebSocket connections with services in the sandbox.

**Common use cases:**

* Route incoming WebSocket upgrade requests with custom authentication or authorization
* Connect from your Worker to get real-time data from sandbox services

For exposing WebSocket services via public preview URLs, use `exposePort()` with `proxyToSandbox()` instead. See [WebSocket Connections guide](https://developers.cloudflare.com/sandbox/guides/websocket-connections/) for examples.

```ts
const response = await sandbox.wsConnect(request: Request, port: number): Promise<Response>
```

**Parameters**:

* `request` - Incoming WebSocket upgrade request
* `port` - Port number (1024-65535, excluding 3000)

**Returns**: `Promise<Response>` - WebSocket response establishing the connection

* JavaScript

  ```js
  import { getSandbox } from "@cloudflare/sandbox";


  export { Sandbox } from "@cloudflare/sandbox";


  export default {
    async fetch(request, env) {
      if (request.headers.get("Upgrade")?.toLowerCase() === "websocket") {
        const sandbox = getSandbox(env.Sandbox, "my-sandbox");
        return await sandbox.wsConnect(request, 8080);
      }


      return new Response("WebSocket endpoint", { status: 200 });
    },
  };
  ```

* TypeScript

  ```ts
  import { getSandbox } from "@cloudflare/sandbox";


  export { Sandbox } from "@cloudflare/sandbox";


  export default {
    async fetch(request: Request, env: Env): Promise<Response> {
      if (request.headers.get('Upgrade')?.toLowerCase() === 'websocket') {
        const sandbox = getSandbox(env.Sandbox, 'my-sandbox');
        return await sandbox.wsConnect(request, 8080);
      }


      return new Response('WebSocket endpoint', { status: 200 });
    }
  };
  ```

## Related resources

* [Preview URLs concept](https://developers.cloudflare.com/sandbox/concepts/preview-urls/) - How preview URLs work
* [Commands API](https://developers.cloudflare.com/sandbox/api/commands/) - Start background processes

</page>

<page>
---
title: Sessions · Cloudflare Sandbox SDK docs
description: Create isolated execution contexts within a sandbox. Each session
  maintains its own shell state, environment variables, and working directory.
  See Session management concept for details.
lastUpdated: 2026-02-09T23:08:08.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/api/sessions/
  md: https://developers.cloudflare.com/sandbox/api/sessions/index.md
---

Create isolated execution contexts within a sandbox. Each session maintains its own shell state, environment variables, and working directory. See [Session management concept](https://developers.cloudflare.com/sandbox/concepts/sessions/) for details.

Note

Every sandbox has a default session that automatically maintains shell state. Create additional sessions when you need isolated shell contexts for different environments or parallel workflows. For sandbox-level operations like creating containers or destroying the entire sandbox, see the [Lifecycle API](https://developers.cloudflare.com/sandbox/api/lifecycle/).

## Methods

### `createSession()`

Create a new isolated execution session.

```ts
const session = await sandbox.createSession(options?: SessionOptions): Promise<ExecutionSession>
```

**Parameters**:

* `options` (optional):

  * `id` - Custom session ID (auto-generated if not provided)
  * `env` - Environment variables for this session: `Record<string, string | undefined>`
  * `cwd` - Working directory (default: `"/workspace"`)

**Returns**: `Promise<ExecutionSession>` with all sandbox methods bound to this session

* JavaScript

  ```js
  // Multiple isolated environments
  const prodSession = await sandbox.createSession({
    id: "prod",
    env: { NODE_ENV: "production", API_URL: "https://api.example.com" },
    cwd: "/workspace/prod",
  });


  const testSession = await sandbox.createSession({
    id: "test",
    env: {
      NODE_ENV: "test",
      API_URL: "http://localhost:3000",
      DEBUG_MODE: undefined, // Skipped, not set in this session
    },
    cwd: "/workspace/test",
  });


  // Run in parallel
  const [prodResult, testResult] = await Promise.all([
    prodSession.exec("npm run build"),
    testSession.exec("npm run build"),
  ]);
  ```

* TypeScript

  ```ts
  // Multiple isolated environments
  const prodSession = await sandbox.createSession({
    id: 'prod',
    env: { NODE_ENV: 'production', API_URL: 'https://api.example.com' },
    cwd: '/workspace/prod'
  });


  const testSession = await sandbox.createSession({
    id: 'test',
    env: {
      NODE_ENV: 'test',
      API_URL: 'http://localhost:3000',
      DEBUG_MODE: undefined // Skipped, not set in this session
    },
    cwd: '/workspace/test'
  });


  // Run in parallel
  const [prodResult, testResult] = await Promise.all([
    prodSession.exec('npm run build'),
    testSession.exec('npm run build')
  ]);
  ```

### `getSession()`

Retrieve an existing session by ID.

```ts
const session = await sandbox.getSession(sessionId: string): Promise<ExecutionSession>
```

**Parameters**:

* `sessionId` - ID of an existing session

**Returns**: `Promise<ExecutionSession>` bound to the specified session

* JavaScript

  ```js
  // First request - create session
  const session = await sandbox.createSession({ id: "user-123" });
  await session.exec("git clone https://github.com/user/repo.git");
  await session.exec("cd repo && npm install");


  // Second request - resume session (environment and cwd preserved)
  const session = await sandbox.getSession("user-123");
  const result = await session.exec("cd repo && npm run build");
  ```

* TypeScript

  ```ts
  // First request - create session
  const session = await sandbox.createSession({ id: 'user-123' });
  await session.exec('git clone https://github.com/user/repo.git');
  await session.exec('cd repo && npm install');


  // Second request - resume session (environment and cwd preserved)
  const session = await sandbox.getSession('user-123');
  const result = await session.exec('cd repo && npm run build');
  ```

***

### `deleteSession()`

Delete a session and clean up its resources.

```ts
const result = await sandbox.deleteSession(sessionId: string): Promise<SessionDeleteResult>
```

**Parameters**:

* `sessionId` - ID of the session to delete (cannot be `"default"`)

**Returns**: `Promise<SessionDeleteResult>` containing:

* `success` - Whether deletion succeeded
* `sessionId` - ID of the deleted session
* `timestamp` - Deletion timestamp

- JavaScript

  ```js
  // Create a temporary session for a specific task
  const tempSession = await sandbox.createSession({ id: "temp-task" });


  try {
    await tempSession.exec("npm run heavy-task");
  } finally {
    // Clean up the session when done
    await sandbox.deleteSession("temp-task");
  }
  ```

- TypeScript

  ```ts
  // Create a temporary session for a specific task
  const tempSession = await sandbox.createSession({ id: 'temp-task' });


  try {
    await tempSession.exec('npm run heavy-task');
  } finally {
    // Clean up the session when done
    await sandbox.deleteSession('temp-task');
  }
  ```

Warning

Deleting a session immediately terminates all running commands. The default session cannot be deleted.

***

### `setEnvVars()`

Set environment variables in the sandbox.

```ts
await sandbox.setEnvVars(envVars: Record<string, string | undefined>): Promise<void>
```

**Parameters**:

* `envVars` - Key-value pairs of environment variables to set or unset

  * `string` values: Set the environment variable
  * `undefined` or `null` values: Unset the environment variable

Warning

Call `setEnvVars()` **before** any other sandbox operations to ensure environment variables are available from the start.

* JavaScript

  ```js
  const sandbox = getSandbox(env.Sandbox, "user-123");


  // Set environment variables first
  await sandbox.setEnvVars({
    API_KEY: env.OPENAI_API_KEY,
    DATABASE_URL: env.DATABASE_URL,
    NODE_ENV: "production",
    OLD_TOKEN: undefined, // Unsets OLD_TOKEN if previously set
  });


  // Now commands can access these variables
  await sandbox.exec("python script.py");
  ```

* TypeScript

  ```ts
  const sandbox = getSandbox(env.Sandbox, 'user-123');


  // Set environment variables first
  await sandbox.setEnvVars({
    API_KEY: env.OPENAI_API_KEY,
    DATABASE_URL: env.DATABASE_URL,
    NODE_ENV: 'production',
    OLD_TOKEN: undefined // Unsets OLD_TOKEN if previously set
  });


  // Now commands can access these variables
  await sandbox.exec('python script.py');
  ```

***

## ExecutionSession methods

The `ExecutionSession` object has all sandbox methods bound to the specific session:

| Category | Methods |
| - | - |
| **Commands** | [`exec()`](https://developers.cloudflare.com/sandbox/api/commands/#exec), [`execStream()`](https://developers.cloudflare.com/sandbox/api/commands/#execstream) |
| **Processes** | [`startProcess()`](https://developers.cloudflare.com/sandbox/api/commands/#startprocess), [`listProcesses()`](https://developers.cloudflare.com/sandbox/api/commands/#listprocesses), [`killProcess()`](https://developers.cloudflare.com/sandbox/api/commands/#killprocess), [`killAllProcesses()`](https://developers.cloudflare.com/sandbox/api/commands/#killallprocesses), [`getProcessLogs()`](https://developers.cloudflare.com/sandbox/api/commands/#getprocesslogs), [`streamProcessLogs()`](https://developers.cloudflare.com/sandbox/api/commands/#streamprocesslogs) |
| **Files** | [`writeFile()`](https://developers.cloudflare.com/sandbox/api/files/#writefile), [`readFile()`](https://developers.cloudflare.com/sandbox/api/files/#readfile), [`mkdir()`](https://developers.cloudflare.com/sandbox/api/files/#mkdir), [`deleteFile()`](https://developers.cloudflare.com/sandbox/api/files/#deletefile), [`renameFile()`](https://developers.cloudflare.com/sandbox/api/files/#renamefile), [`moveFile()`](https://developers.cloudflare.com/sandbox/api/files/#movefile), [`gitCheckout()`](https://developers.cloudflare.com/sandbox/api/files/#gitcheckout) |
| **Environment** | [`setEnvVars()`](https://developers.cloudflare.com/sandbox/api/sessions/#setenvvars) |
| **Terminal** | [`terminal()`](https://developers.cloudflare.com/sandbox/api/terminal/#terminal) |
| **Code Interpreter** | [`createCodeContext()`](https://developers.cloudflare.com/sandbox/api/interpreter/#createcodecontext), [`runCode()`](https://developers.cloudflare.com/sandbox/api/interpreter/#runcode), [`listCodeContexts()`](https://developers.cloudflare.com/sandbox/api/interpreter/#listcodecontexts), [`deleteCodeContext()`](https://developers.cloudflare.com/sandbox/api/interpreter/#deletecodecontext) |

## Related resources

* [Session management concept](https://developers.cloudflare.com/sandbox/concepts/sessions/) - How sessions work
* [Commands API](https://developers.cloudflare.com/sandbox/api/commands/) - Execute commands

</page>

<page>
---
title: Storage · Cloudflare Sandbox SDK docs
description: Mount S3-compatible storage buckets (R2, S3, GCS) into the sandbox
  filesystem for persistent data access.
lastUpdated: 2026-02-08T17:20:18.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/api/storage/
  md: https://developers.cloudflare.com/sandbox/api/storage/index.md
---

Mount S3-compatible storage buckets (R2, S3, GCS) into the sandbox filesystem for persistent data access.

## Methods

### `mountBucket()`

Mount an S3-compatible bucket to a local path in the sandbox.

```ts
await sandbox.mountBucket(
  bucket: string,
  mountPath: string,
  options: MountBucketOptions
): Promise<void>
```

**Parameters**:

* `bucket` - Bucket name (e.g., `"my-r2-bucket"`)
* `mountPath` - Local filesystem path to mount at (e.g., `"/data"`)
* `options` - Mount configuration (see [`MountBucketOptions`](#mountbucketoptions))

- JavaScript

  ```js
  // Mount R2 bucket to /data
  await sandbox.mountBucket("my-bucket", "/data", {
    endpoint: "https://YOUR_ACCOUNT_ID.r2.cloudflarestorage.com",
    provider: "r2",
  });


  // Read/write files directly
  const data = await sandbox.readFile("/data/config.json");
  await sandbox.writeFile("/data/results.json", JSON.stringify(data));


  // Mount with explicit credentials
  await sandbox.mountBucket("my-bucket", "/storage", {
    endpoint: "https://s3.amazonaws.com",
    credentials: {
      accessKeyId: env.AWS_ACCESS_KEY_ID,
      secretAccessKey: env.AWS_SECRET_ACCESS_KEY,
    },
  });


  // Read-only mount
  await sandbox.mountBucket("datasets", "/datasets", {
    endpoint: "https://YOUR_ACCOUNT_ID.r2.cloudflarestorage.com",
    readOnly: true,
  });


  // Mount a subdirectory within the bucket
  await sandbox.mountBucket("shared-bucket", "/user-data", {
    endpoint: "https://YOUR_ACCOUNT_ID.r2.cloudflarestorage.com",
    prefix: "/users/user-123/",
  });
  ```

- TypeScript

  ```ts
  // Mount R2 bucket to /data
  await sandbox.mountBucket('my-bucket', '/data', {
    endpoint: 'https://YOUR_ACCOUNT_ID.r2.cloudflarestorage.com',
    provider: 'r2'
  });


  // Read/write files directly
  const data = await sandbox.readFile('/data/config.json');
  await sandbox.writeFile('/data/results.json', JSON.stringify(data));


  // Mount with explicit credentials
  await sandbox.mountBucket('my-bucket', '/storage', {
    endpoint: 'https://s3.amazonaws.com',
    credentials: {
      accessKeyId: env.AWS_ACCESS_KEY_ID,
      secretAccessKey: env.AWS_SECRET_ACCESS_KEY
    }
  });


  // Read-only mount
  await sandbox.mountBucket('datasets', '/datasets', {
    endpoint: 'https://YOUR_ACCOUNT_ID.r2.cloudflarestorage.com',
    readOnly: true
  });


  // Mount a subdirectory within the bucket
  await sandbox.mountBucket('shared-bucket', '/user-data', {
    endpoint: 'https://YOUR_ACCOUNT_ID.r2.cloudflarestorage.com',
    prefix: '/users/user-123/'
  });
  ```

**Throws**:

* `InvalidMountPointError` - Invalid mount path or conflicts with existing mounts
* `BucketAccessError` - Bucket does not exist or insufficient permissions

Authentication

Credentials can be provided via:

1. Explicit `credentials` in options
2. Environment variables (`AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`)
3. Automatic detection from bound R2 buckets

See the [Mount Buckets guide](https://developers.cloudflare.com/sandbox/guides/mount-buckets/) for detailed authentication options.

### `unmountBucket()`

Unmount a previously mounted bucket.

```ts
await sandbox.unmountBucket(mountPath: string): Promise<void>
```

**Parameters**:

* `mountPath` - Path where the bucket is mounted (e.g., `"/data"`)

- JavaScript

  ```js
  // Mount, process, unmount
  await sandbox.mountBucket("data", "/data", { endpoint: "..." });
  await sandbox.exec("python process.py");


  // Unmount
  await sandbox.unmountBucket("/data");
  ```

- TypeScript

  ```ts
  // Mount, process, unmount
  await sandbox.mountBucket('data', '/data', { endpoint: '...' });
  await sandbox.exec('python process.py');


  // Unmount
  await sandbox.unmountBucket('/data');
  ```

Automatic cleanup

Mounted buckets are automatically unmounted when the container is destroyed.

## Types

### `MountBucketOptions`

```ts
interface MountBucketOptions {
  endpoint: string;
  provider?: BucketProvider;
  credentials?: BucketCredentials;
  readOnly?: boolean;
  prefix?: string;
  s3fsOptions?: Record<string, string>;
}
```

**Fields**:

* `endpoint` (required) - S3-compatible endpoint URL

  * R2: `'https://YOUR_ACCOUNT_ID.r2.cloudflarestorage.com'`
  * S3: `'https://s3.amazonaws.com'`
  * GCS: `'https://storage.googleapis.com'`

* `provider` (optional) - Storage provider hint

  * Enables provider-specific optimizations
  * Values: `'r2'`, `'s3'`, `'gcs'`

* `credentials` (optional) - API credentials

  * Contains `accessKeyId` and `secretAccessKey`
  * If not provided, uses environment variables

* `readOnly` (optional) - Mount in read-only mode

  * Default: `false`

* `prefix` (optional) - Subdirectory within the bucket to mount

  * When specified, only contents under this prefix are visible at the mount point
  * Must start and end with `/` (e.g., `/data/uploads/`)
  * Default: Mount entire bucket

* `s3fsOptions` (optional) - Advanced s3fs mount flags

  * Example: `{ 'use_cache': '/tmp/cache' }`

### `BucketProvider`

Storage provider hint for automatic s3fs flag optimization.

```ts
type BucketProvider = "r2" | "s3" | "gcs";
```

* `'r2'` - Cloudflare R2 (recommended, applies `nomixupload` flag)
* `'s3'` - Amazon S3
* `'gcs'` - Google Cloud Storage

## Related resources

* [Mount Buckets guide](https://developers.cloudflare.com/sandbox/guides/mount-buckets/) - Complete bucket mounting walkthrough
* [Files API](https://developers.cloudflare.com/sandbox/api/files/) - Read and write files

</page>

<page>
---
title: Terminal · Cloudflare Sandbox SDK docs
description: Connect browser-based terminal UIs to sandbox shells via WebSocket.
lastUpdated: 2026-02-09T23:08:08.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/api/terminal/
  md: https://developers.cloudflare.com/sandbox/api/terminal/index.md
---

Connect browser-based terminal UIs to sandbox shells via WebSocket. The server-side `terminal()` method proxies WebSocket connections to the container, and the client-side `SandboxAddon` integrates with xterm.js for terminal rendering.

## Server-side methods

### `terminal()`

Proxy a WebSocket upgrade request to create a terminal connection.

```ts
const response = await sandbox.terminal(request: Request, options?: PtyOptions): Promise<Response>
```

**Parameters**:

* `request` - WebSocket upgrade request from the browser (must include `Upgrade: websocket` header)

* `options` (optional):

  * `cols` - Terminal width in columns (default: `80`)
  * `rows` - Terminal height in rows (default: `24`)

**Returns**: `Promise<Response>` — WebSocket upgrade response

* JavaScript

  ```js
  // In your Worker's fetch handler
  return await sandbox.terminal(request, { cols: 120, rows: 30 });
  ```

* TypeScript

  ```ts
  // In your Worker's fetch handler
  return await sandbox.terminal(request, { cols: 120, rows: 30 });
  ```

Works with both [default and explicitly created sessions](https://developers.cloudflare.com/sandbox/concepts/sessions/):

* JavaScript

  ```js
  // Default session
  return await sandbox.terminal(request);


  // Specific session
  const session = await sandbox.getSession("dev");
  return await session.terminal(request);
  ```

* TypeScript

  ```ts
  // Default session
  return await sandbox.terminal(request);


  // Specific session
  const session = await sandbox.getSession('dev');
  return await session.terminal(request);
  ```

## Client-side addon

The `@cloudflare/sandbox/xterm` module provides `SandboxAddon` for xterm.js, which handles the WebSocket connection, reconnection, and terminal resize forwarding.

### `SandboxAddon`

```ts
import { SandboxAddon } from '@cloudflare/sandbox/xterm';


const addon = new SandboxAddon(options: SandboxAddonOptions);
```

**Options**:

* `getWebSocketUrl(params)` - Build the WebSocket URL for each connection attempt. Receives:

  * `sandboxId` - Target sandbox ID
  * `sessionId` (optional) - Target session ID
  * `origin` - WebSocket origin derived from `window.location` (for example, `wss://example.com`)

* `reconnect` - Enable automatic reconnection with exponential backoff (default: `true`)

* `onStateChange(state, error?)` - Callback for connection state changes

- JavaScript

  ```js
  import { Terminal } from "@xterm/xterm";
  import { SandboxAddon } from "@cloudflare/sandbox/xterm";


  const terminal = new Terminal({ cursorBlink: true });
  terminal.open(document.getElementById("terminal"));


  const addon = new SandboxAddon({
    getWebSocketUrl: ({ sandboxId, sessionId, origin }) => {
      const params = new URLSearchParams({ id: sandboxId });
      if (sessionId) params.set("session", sessionId);
      return `${origin}/ws/terminal?${params}`;
    },
    onStateChange: (state, error) => {
      console.log(`Terminal ${state}`, error);
    },
  });


  terminal.loadAddon(addon);
  addon.connect({ sandboxId: "my-sandbox" });
  ```

- TypeScript

  ```ts
  import { Terminal } from '@xterm/xterm';
  import { SandboxAddon } from '@cloudflare/sandbox/xterm';


  const terminal = new Terminal({ cursorBlink: true });
  terminal.open(document.getElementById('terminal'));


  const addon = new SandboxAddon({
    getWebSocketUrl: ({ sandboxId, sessionId, origin }) => {
      const params = new URLSearchParams({ id: sandboxId });
      if (sessionId) params.set('session', sessionId);
      return `${origin}/ws/terminal?${params}`;
    },
    onStateChange: (state, error) => {
      console.log(`Terminal ${state}`, error);
    }
  });


  terminal.loadAddon(addon);
  addon.connect({ sandboxId: 'my-sandbox' });
  ```

### `connect()`

Establish a connection to a sandbox terminal.

```ts
addon.connect(target: ConnectionTarget): void
```

**Parameters**:

* `target`:

  * `sandboxId` - Sandbox to connect to
  * `sessionId` (optional) - Session within the sandbox

Calling `connect()` with a new target disconnects from the current target and connects to the new one. Calling it with the same target while already connected is a no-op.

### `disconnect()`

Close the connection and stop any reconnection attempts.

```ts
addon.disconnect(): void
```

### Properties

| Property | Type | Description |
| - | - | - |
| `state` | `'disconnected' \| 'connecting' \| 'connected'` | Current connection state |
| `sandboxId` | `string \| undefined` | Current sandbox ID |
| `sessionId` | `string \| undefined` | Current session ID |

## WebSocket protocol

The `SandboxAddon` handles the WebSocket protocol automatically. These details are for building custom terminal clients without the addon. For a complete example, refer to [Connect without xterm.js](https://developers.cloudflare.com/sandbox/guides/browser-terminals/#connect-without-xtermjs).

### Connection lifecycle

1. Client opens a WebSocket to your Worker endpoint. Set `binaryType` to `arraybuffer`.
2. The server replays any **buffered output** from a previous connection as binary frames. This may arrive before the `ready` message.
3. The server sends a `ready` status message — the terminal is now accepting input.
4. Binary frames flow in both directions: UTF-8 encoded keystrokes from the client, terminal output (including ANSI escape sequences) from the server.
5. If the client disconnects, the PTY stays alive. Reconnecting to the same session replays buffered output so the terminal appears unchanged.

### Control messages (client to server)

Send JSON text frames to control the terminal.

**Resize** — update terminal dimensions (both `cols` and `rows` must be positive):

```json
{ "type": "resize", "cols": 120, "rows": 30 }
```

### Status messages (server to client)

The server sends JSON text frames for lifecycle events.

**Ready** — the PTY is initialized. Buffered output (if any) has already been sent:

```json
{ "type": "ready" }
```

**Exit** — the shell process has terminated:

```json
{ "type": "exit", "code": 0, "signal": "SIGTERM" }
```

**Error** — an error occurred (for example, invalid control message or session not found):

```json
{ "type": "error", "message": "Session not found" }
```

## Types

```ts
interface PtyOptions {
  cols?: number;
  rows?: number;
}


type ConnectionState = "disconnected" | "connecting" | "connected";


interface ConnectionTarget {
  sandboxId: string;
  sessionId?: string;
}


interface SandboxAddonOptions {
  getWebSocketUrl: (params: {
    sandboxId: string;
    sessionId?: string;
    origin: string;
  }) => string;
  reconnect?: boolean;
  onStateChange?: (state: ConnectionState, error?: Error) => void;
}
```

## Related resources

* [Terminal connections](https://developers.cloudflare.com/sandbox/concepts/terminal/) — How terminal connections work
* [Browser terminals](https://developers.cloudflare.com/sandbox/guides/browser-terminals/) — Step-by-step setup guide
* [Sessions API](https://developers.cloudflare.com/sandbox/api/sessions/) — Session management
* [Commands API](https://developers.cloudflare.com/sandbox/api/commands/) — Non-interactive command execution

</page>

<page>
---
title: Architecture · Cloudflare Sandbox SDK docs
description: "Sandbox SDK lets you execute untrusted code safely from your
  Workers. It combines three Cloudflare technologies to provide secure,
  stateful, and isolated execution:"
lastUpdated: 2026-02-10T11:20:23.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/concepts/architecture/
  md: https://developers.cloudflare.com/sandbox/concepts/architecture/index.md
---

Sandbox SDK lets you execute untrusted code safely from your Workers. It combines three Cloudflare technologies to provide secure, stateful, and isolated execution:

* **Workers** - Your application logic that calls the Sandbox SDK
* **Durable Objects** - Persistent sandbox instances with unique identities
* **Containers** - Isolated Linux environments where code actually runs

## Architecture overview

```mermaid
flowchart TB
    accTitle: Sandbox SDK Architecture
    accDescr: Three-layer architecture showing how Cloudflare Sandbox SDK combines Workers, Durable Objects, and Containers for secure code execution

    subgraph UserSpace["<b>Your Worker</b>"]
        Worker["Application code using the methods exposed by the Sandbox SDK"]
    end

    subgraph SDKSpace["<b>Sandbox SDK Implementation</b>"]
        DO["Sandbox Durable Object routes requests & maintains state"]
        Container["Isolated Ubuntu container executes untrusted code safely"]

        DO -->|HTTP API| Container
    end

    Worker -->|RPC call via the Durable Object stub returned by `getSandbox`| DO

    style UserSpace fill:#fff8f0,stroke:#f6821f,stroke-width:2px
    style SDKSpace fill:#f5f5f5,stroke:#666,stroke-width:2px,stroke-dasharray: 5 5
    style Worker fill:#ffe8d1,stroke:#f6821f,stroke-width:2px
    style DO fill:#dce9f7,stroke:#1d8cf8,stroke-width:2px
    style Container fill:#d4f4e2,stroke:#17b26a,stroke-width:2px
```

### Layer 1: Client SDK

The developer-facing API you use in your Workers:

```typescript
import { getSandbox } from "@cloudflare/sandbox";


const sandbox = getSandbox(env.Sandbox, "my-sandbox");
const result = await sandbox.exec("python script.py");
```

**Purpose**: Provide a clean, type-safe TypeScript interface for all sandbox operations.

### Layer 2: Durable Object

Manages sandbox lifecycle and routing:

```typescript
export class Sandbox extends DurableObject<Env> {
  // Extends Cloudflare Container for isolation
  // Routes requests between client and container
  // Manages preview URLs and state
}
```

**Purpose**: Provide persistent, stateful sandbox instances with unique identities.

**Why Durable Objects**:

* **Persistent identity** - Same sandbox ID always routes to same instance
* **Container management** - Durable Object owns and manages the container lifecycle
* **Geographic distribution** - Sandboxes run close to users
* **Automatic scaling** - Cloudflare manages provisioning

### Layer 3: Container Runtime

Executes code in isolation with full Linux capabilities.

**Purpose**: Safely execute untrusted code.

**Why containers**:

* **VM-based isolation** - Each sandbox runs in its own VM
* **Full environment** - Ubuntu Linux with Python, Node.js, Git, etc.

## Communication transports

The SDK supports two transport protocols for communication between the Durable Object and container:

### HTTP transport (default)

Each SDK method makes a separate HTTP request to the container API. Simple, reliable, and works for most use cases.

```typescript
// Default behavior - uses HTTP
const sandbox = getSandbox(env.Sandbox, "my-sandbox");
await sandbox.exec("python script.py");
```

### WebSocket transport

Multiplexes all SDK calls over a single persistent WebSocket connection. Avoids [subrequest limits](https://developers.cloudflare.com/workers/platform/limits/#subrequests) when making many concurrent operations.

Enable WebSocket transport by setting the `SANDBOX_TRANSPORT` variable in your Worker's configuration:

* wrangler.jsonc

  ```jsonc
  {
    "vars": {
      "SANDBOX_TRANSPORT": "websocket"
    },
  }
  ```

* wrangler.toml

  ```toml
  [vars]
  SANDBOX_TRANSPORT = "websocket"
  ```

The transport layer is transparent to your application code - all SDK methods work identically regardless of transport. See [Transport modes](https://developers.cloudflare.com/sandbox/configuration/transport/) for details on when to use each transport and configuration examples.

## Request flow

When you execute a command:

```typescript
await sandbox.exec("python script.py");
```

**HTTP transport flow**:

1. **Client SDK** validates parameters and sends HTTP request to Durable Object
2. **Durable Object** authenticates and forwards HTTP request to container
3. **Container Runtime** validates inputs, executes command, captures output
4. **Response flows back** through all layers with proper error transformation

**WebSocket transport flow**:

1. **Client SDK** validates parameters and sends request over persistent WebSocket connection
2. **Durable Object** maintains WebSocket connection, multiplexes concurrent requests
3. **Container Runtime** adapts WebSocket messages to HTTP-style request/response
4. **Response flows back** over same WebSocket connection with proper error transformation

The WebSocket connection is established on first SDK call and reused for all subsequent operations, reducing overhead for high-frequency operations.

## Related resources

* [Sandbox lifecycle](https://developers.cloudflare.com/sandbox/concepts/sandboxes/) - How sandboxes are created and managed
* [Container runtime](https://developers.cloudflare.com/sandbox/concepts/containers/) - Inside the execution environment
* [Security model](https://developers.cloudflare.com/sandbox/concepts/security/) - How isolation and validation work
* [Session management](https://developers.cloudflare.com/sandbox/concepts/sessions/) - Advanced state management

</page>

<page>
---
title: Container runtime · Cloudflare Sandbox SDK docs
description: Each sandbox runs in an isolated Linux container with Python,
  Node.js, and common development tools pre-installed. For a complete list of
  pre-installed software and how to customize the container image, see
  Dockerfile reference.
lastUpdated: 2025-11-08T10:22:38.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/concepts/containers/
  md: https://developers.cloudflare.com/sandbox/concepts/containers/index.md
---

Each sandbox runs in an isolated Linux container with Python, Node.js, and common development tools pre-installed. For a complete list of pre-installed software and how to customize the container image, see [Dockerfile reference](https://developers.cloudflare.com/sandbox/configuration/dockerfile/).

## Runtime software installation

Install additional software at runtime using standard package managers:

```bash
# Python packages
pip install scikit-learn tensorflow


# Node.js packages
npm install express


# System packages (requires apt-get update first)
apt-get update && apt-get install -y redis-server
```

## Filesystem

The container provides a standard Linux filesystem. You can read and write anywhere you have permissions.

**Standard directories**:

* `/workspace` - Default working directory for user code
* `/tmp` - Temporary files
* `/home` - User home directory
* `/usr/bin`, `/usr/local/bin` - Executable binaries

**Example**:

```typescript
await sandbox.writeFile('/workspace/app.py', 'print("Hello")');
await sandbox.writeFile('/tmp/cache.json', '{}');
await sandbox.exec('ls -la /workspace');
```

## Process management

Processes run as you'd expect in a regular Linux environment.

**Foreground processes** (`exec()`):

```typescript
const result = await sandbox.exec('npm test');
// Waits for completion, returns output
```

**Background processes** (`startProcess()`):

```typescript
const process = await sandbox.startProcess('node server.js');
// Returns immediately, process runs in background
```

## Network capabilities

**Outbound connections** work:

```bash
curl https://api.example.com/data
pip install requests
npm install express
```

**Inbound connections** require port exposure:

```typescript
const { hostname } = new URL(request.url);
await sandbox.startProcess('python -m http.server 8000');
const exposed = await sandbox.exposePort(8000, { hostname });
console.log(exposed.exposedAt); // Public URL
```

Local development

When using `wrangler dev`, you must add `EXPOSE` directives to your Dockerfile for each port. See [Local development with ports](https://developers.cloudflare.com/sandbox/guides/expose-services/#local-development).

**Localhost** works within sandbox:

```bash
redis-server &      # Start server
redis-cli ping      # Connect locally
```

## Security

**Between sandboxes** (isolated):

* Each sandbox is a separate container
* Filesystem, memory and network are all isolated

**Within sandbox** (shared):

* All processes see the same files
* Processes can communicate with each other
* Environment variables are session-scoped

To run untrusted code, use separate sandboxes per user:

```typescript
const sandbox = getSandbox(env.Sandbox, `user-${userId}`);
```

## Limitations

**Cannot**:

* Load kernel modules or access host hardware
* Run nested containers (no Docker-in-Docker)

## Related resources

* [Architecture](https://developers.cloudflare.com/sandbox/concepts/architecture/) - How containers fit in the system
* [Security model](https://developers.cloudflare.com/sandbox/concepts/security/) - Container isolation details
* [Sandbox lifecycle](https://developers.cloudflare.com/sandbox/concepts/sandboxes/) - Container lifecycle management

</page>

<page>
---
title: Preview URLs · Cloudflare Sandbox SDK docs
description: Preview URLs provide public HTTPS access to services running inside
  sandboxes. When you expose a port, you get a unique URL that proxies requests
  to your service.
lastUpdated: 2026-02-06T17:32:05.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/concepts/preview-urls/
  md: https://developers.cloudflare.com/sandbox/concepts/preview-urls/index.md
---

Production requires custom domain

Preview URLs work in local development without configuration. For production, you need a custom domain with wildcard DNS routing. See [Production Deployment](https://developers.cloudflare.com/sandbox/guides/production-deployment/).

Preview URLs provide public HTTPS access to services running inside sandboxes. When you expose a port, you get a unique URL that proxies requests to your service.

```typescript
// Extract hostname from request
const { hostname } = new URL(request.url);


await sandbox.startProcess("python -m http.server 8000");
const exposed = await sandbox.exposePort(8000, { hostname });


console.log(exposed.url);
// Production: https://8000-sandbox-id-abc123random4567.yourdomain.com
// Local dev: http://localhost:8787/...
```

## URL Format

**Production**: `https://{port}-{sandbox-id}-{token}.yourdomain.com`

* With auto-generated token: `https://8080-abc123-random16chars12.yourdomain.com`
* With custom token: `https://8080-abc123-my-api-v1.yourdomain.com`

**Local development**: `http://localhost:8787/...`

## Token Types

### Auto-generated tokens (default)

When no custom token is specified, a random 16-character token is generated:

```typescript
const exposed = await sandbox.exposePort(8000, { hostname });
// https://8000-sandbox-id-abc123random4567.yourdomain.com
```

URLs with auto-generated tokens change when you unexpose and re-expose a port.

### Custom tokens for stable URLs

For production deployments or shared URLs, specify a custom token to maintain consistency across container restarts:

```typescript
const stable = await sandbox.exposePort(8000, {
  hostname,
  token: 'api-v1'
});
// https://8000-sandbox-id-api-v1.yourdomain.com
// Same URL every time ✓
```

**Token requirements:**

* 1-16 characters long
* Lowercase letters (a-z), numbers (0-9), hyphens (-), and underscores (\_) only
* Must be unique within each sandbox

**Use cases for custom tokens:**

* Production APIs with stable endpoints
* Sharing demo URLs with external users
* Documentation with consistent examples
* Integration testing with predictable URLs

## ID Case Sensitivity

Preview URLs extract the sandbox ID from the hostname to route requests. Since hostnames are case-insensitive (per RFC 3986), they're always lowercased: `8080-MyProject-123.yourdomain.com` becomes `8080-myproject-123.yourdomain.com`.

**The problem**: If you create a sandbox with `"MyProject-123"`, it exists as a Durable Object with that exact ID. But the preview URL routes to `"myproject-123"` (lowercased from the hostname). These are different Durable Objects, so your sandbox is unreachable via preview URL.

```typescript
// Problem scenario
const sandbox = getSandbox(env.Sandbox, 'MyProject-123');
// Durable Object ID: "MyProject-123"
await sandbox.exposePort(8080, { hostname });
// Preview URL: 8080-myproject-123-token123.yourdomain.com
// Routes to: "myproject-123" (different DO - doesn't exist!)
```

**The solution**: Use `normalizeId: true` to lowercase IDs when creating sandboxes:

```typescript
const sandbox = getSandbox(env.Sandbox, 'MyProject-123', {
  normalizeId: true
});
// Durable Object ID: "myproject-123" (lowercased)
// Preview URL: 8080-myproject-123-token123.yourdomain.com
// Routes to: "myproject-123" (same DO - works!)
```

Without `normalizeId: true`, `exposePort()` throws an error when the ID contains uppercase letters.

**Best practice**: Use lowercase IDs from the start (`'my-project-123'`). See [Sandbox options - normalizeId](https://developers.cloudflare.com/sandbox/configuration/sandbox-options/#normalizeid) for details.

## Request Routing

You must call `proxyToSandbox()` first in your Worker's fetch handler to route preview URL requests:

```typescript
import { proxyToSandbox, getSandbox } from "@cloudflare/sandbox";


export { Sandbox } from "@cloudflare/sandbox";


export default {
  async fetch(request, env) {
    // Handle preview URL routing first
    const proxyResponse = await proxyToSandbox(request, env);
    if (proxyResponse) return proxyResponse;


    // Your application routes
    // ...
  },
};
```

Requests flow: Browser → Your Worker → Durable Object (sandbox) → Your Service.

## Multiple Ports

Expose multiple services simultaneously:

```typescript
// Extract hostname from request
const { hostname } = new URL(request.url);


await sandbox.startProcess("node api.js"); // Port 3000
await sandbox.startProcess("node admin.js"); // Port 3001


const api = await sandbox.exposePort(3000, { hostname, name: "api" });
const admin = await sandbox.exposePort(3001, { hostname, name: "admin" });


// Each gets its own URL with unique tokens:
// https://3000-abc123-random16chars01.yourdomain.com
// https://3001-abc123-random16chars02.yourdomain.com
```

## What Works

* HTTP/HTTPS requests
* WebSocket connections
* Server-Sent Events
* All HTTP methods (GET, POST, PUT, DELETE, etc.)
* Request and response headers

## What Does Not Work

* Raw TCP/UDP connections
* Custom protocols (must wrap in HTTP)
* Ports outside range 1024-65535
* Port 3000 (used internally by the SDK)

## WebSocket Support

Preview URLs support WebSocket connections. When a WebSocket upgrade request hits an exposed port, the routing layer automatically handles the connection handshake.

```typescript
// Extract hostname from request
const { hostname } = new URL(request.url);


// Start a WebSocket server
await sandbox.startProcess("bun run ws-server.ts 8080");
const { url } = await sandbox.exposePort(8080, { hostname });


// Clients connect using WebSocket protocol
// Browser: new WebSocket('wss://8080-abc123-token123.yourdomain.com')


// Your Worker routes automatically
export default {
  async fetch(request, env) {
    const proxyResponse = await proxyToSandbox(request, env);
    if (proxyResponse) return proxyResponse;
  },
};
```

For custom routing scenarios where your Worker needs to control which sandbox or port to connect to based on request properties, see `wsConnect()` in the [Ports API](https://developers.cloudflare.com/sandbox/api/ports/#wsconnect).

## Security

Warning

Preview URLs are publicly accessible by default, but require a valid access token that is generated when you expose a port.

**Built-in security**:

* **Token-based access** - Each exposed port gets a unique token in the URL (for example, `https://8080-sandbox-abc123token456.yourdomain.com`)
* **HTTPS in production** - All traffic is encrypted with automatic TLS
* **Unpredictable URLs** - Auto-generated tokens are randomly generated and difficult to guess
* **Token collision prevention** - Custom tokens are validated to ensure uniqueness within each sandbox

**Add application-level authentication**:

For additional security, implement authentication within your application:

```python
from flask import Flask, request, abort


app = Flask(__name__)


@app.route('/data')
def get_data():
    # Check for your own authentication token
    auth_token = request.headers.get('Authorization')
    if auth_token != 'Bearer your-secret-token':
        abort(401)
    return {'data': 'protected'}
```

This adds a second layer of security on top of the URL token.

## Troubleshooting

### URL Not Accessible

Check if service is running and listening:

```typescript
// 1. Is service running?
const processes = await sandbox.listProcesses();


// 2. Is port exposed?
const ports = await sandbox.getExposedPorts();


// 3. Is service binding to 0.0.0.0 (not 127.0.0.1)?
// Good:
app.run((host = "0.0.0.0"), (port = 3000));


// Bad (localhost only):
app.run((host = "127.0.0.1"), (port = 3000));
```

### Production Errors

For custom domain issues, see [Production Deployment troubleshooting](https://developers.cloudflare.com/sandbox/guides/production-deployment/#troubleshooting).

### Local Development

Local development limitation

When using `wrangler dev`, you must expose ports in your Dockerfile:

```dockerfile
FROM docker.io/cloudflare/sandbox:0.3.3


# Required for local development
EXPOSE 3000
EXPOSE 8080
```

Without `EXPOSE`, you'll see: `connect(): Connection refused: container port not found`

This is **only required for local development**. In production, all container ports are automatically accessible.

## Related Resources

* [Production Deployment](https://developers.cloudflare.com/sandbox/guides/production-deployment/) - Set up custom domains for production
* [Expose Services](https://developers.cloudflare.com/sandbox/guides/expose-services/) - Practical patterns for exposing ports
* [Ports API](https://developers.cloudflare.com/sandbox/api/ports/) - Complete API reference
* [Security Model](https://developers.cloudflare.com/sandbox/concepts/security/) - Security best practices

</page>

<page>
---
title: Security model · Cloudflare Sandbox SDK docs
description: The Sandbox SDK is built on Containers, which run each sandbox in
  its own VM for strong isolation.
lastUpdated: 2025-11-08T10:22:38.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/concepts/security/
  md: https://developers.cloudflare.com/sandbox/concepts/security/index.md
---

The Sandbox SDK is built on [Containers](https://developers.cloudflare.com/containers/), which run each sandbox in its own VM for strong isolation.

## Container isolation

Each sandbox runs in a separate VM, providing complete isolation:

* **Filesystem isolation** - Sandboxes cannot access other sandboxes' files
* **Process isolation** - Processes in one sandbox cannot see or affect others
* **Network isolation** - Sandboxes have separate network stacks
* **Resource limits** - CPU, memory, and disk quotas are enforced per sandbox

For complete security details about the underlying container platform, see [Containers architecture](https://developers.cloudflare.com/containers/platform-details/architecture/).

## Within a sandbox

All code within a single sandbox shares resources:

* **Filesystem** - All processes see the same files
* **Processes** - All sessions can see all processes
* **Network** - Processes can communicate via localhost

For complete isolation, use separate sandboxes per user:

```typescript
// Good - Each user in separate sandbox
const userSandbox = getSandbox(env.Sandbox, `user-${userId}`);


// Bad - Users sharing one sandbox
const shared = getSandbox(env.Sandbox, 'shared');
// Users can read each other's files!
```

## Input validation

### Command injection

Always validate user input before using it in commands:

```typescript
// Dangerous - user input directly in command
const filename = userInput;
await sandbox.exec(`cat ${filename}`);
// User could input: "file.txt; rm -rf /"


// Safe - validate input
const filename = userInput.replace(/[^a-zA-Z0-9._-]/g, '');
await sandbox.exec(`cat ${filename}`);


// Better - use file API
await sandbox.writeFile('/tmp/input', userInput);
await sandbox.exec('cat /tmp/input');
```

## Authentication

### Sandbox access

Sandbox IDs provide basic access control but aren't cryptographically secure. Add application-level authentication:

```typescript
export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const userId = await authenticate(request);
    if (!userId) {
      return new Response('Unauthorized', { status: 401 });
    }


    // User can only access their sandbox
    const sandbox = getSandbox(env.Sandbox, userId);
    return Response.json({ authorized: true });
  }
};
```

### Preview URLs

Preview URLs include randomly generated tokens. Anyone with the URL can access the service.

To revoke access, unexpose the port:

```typescript
await sandbox.unexposePort(8080);
```

```python
from flask import Flask, request, abort
import os


app = Flask(__name__)


def check_auth():
    token = request.headers.get('Authorization')
    if token != f"Bearer {os.environ['AUTH_TOKEN']}":
        abort(401)


@app.route('/api/data')
def get_data():
    check_auth()
    return {'data': 'protected'}
```

## Secrets management

Use environment variables, not hardcoded secrets:

```typescript
// Bad - hardcoded in file
await sandbox.writeFile('/workspace/config.js', `
  const API_KEY = 'sk_live_abc123';
`);


// Good - use environment variables
await sandbox.startProcess('node app.js', {
  env: {
    API_KEY: env.API_KEY,  // From Worker environment binding
  }
});
```

Clean up temporary sensitive data:

```typescript
try {
  await sandbox.writeFile('/tmp/sensitive.txt', secretData);
  await sandbox.exec('python process.py /tmp/sensitive.txt');
} finally {
  await sandbox.deleteFile('/tmp/sensitive.txt');
}
```

## What the SDK protects against

* Sandbox-to-sandbox access (VM isolation)
* Resource exhaustion (enforced quotas)
* Container escapes (VM-based isolation)

## What you must implement

* Authentication and authorization
* Input validation and sanitization
* Rate limiting
* Application-level security (SQL injection, XSS, etc.)

## Best practices

**Use separate sandboxes for isolation**:

```typescript
const sandbox = getSandbox(env.Sandbox, `user-${userId}`);
```

**Validate all inputs**:

```typescript
const safe = input.replace(/[^a-zA-Z0-9._-]/g, '');
await sandbox.exec(`command ${safe}`);
```

**Use environment variables for secrets**:

```typescript
await sandbox.startProcess('node app.js', {
  env: { API_KEY: env.API_KEY }
});
```

**Clean up temporary resources**:

```typescript
try {
  const sandbox = getSandbox(env.Sandbox, sessionId);
  await sandbox.exec('npm test');
} finally {
  await sandbox.destroy();
}
```

## Related resources

* [Containers architecture](https://developers.cloudflare.com/containers/platform-details/architecture/) - Underlying platform security
* [Sandbox lifecycle](https://developers.cloudflare.com/sandbox/concepts/sandboxes/) - Resource management

</page>

<page>
---
title: Sandbox lifecycle · Cloudflare Sandbox SDK docs
description: "A sandbox is an isolated execution environment where your code
  runs. Each sandbox:"
lastUpdated: 2026-02-06T17:02:18.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/concepts/sandboxes/
  md: https://developers.cloudflare.com/sandbox/concepts/sandboxes/index.md
---

A sandbox is an isolated execution environment where your code runs. Each sandbox:

* Has a unique identifier (sandbox ID)
* Contains an isolated filesystem
* Runs in a dedicated Linux container
* Maintains state while the container is active
* Exists as a Cloudflare Durable Object

## Lifecycle states

### Creation

A sandbox is created the first time you reference its ID:

```typescript
const sandbox = getSandbox(env.Sandbox, "user-123");
await sandbox.exec('echo "Hello"'); // First request creates sandbox
```

### Active

The sandbox container is running and processing requests. All state remains available: files, running processes, shell sessions, and environment variables.

### Idle

After a period of inactivity (10 minutes by default, configurable via [`sleepAfter`](https://developers.cloudflare.com/sandbox/configuration/sandbox-options/)), the container stops to free resources. When the next request arrives, a fresh container starts. All previous state is lost and the environment resets to its initial state.

**Note**: Containers with [`keepAlive: true`](https://developers.cloudflare.com/sandbox/configuration/sandbox-options/#keepalive) never enter the idle state. They automatically send heartbeat pings every 30 seconds to prevent eviction.

### Destruction

Sandboxes are explicitly destroyed or automatically cleaned up:

```typescript
await sandbox.destroy();
// All files, processes, and state deleted permanently
```

## Container lifetime and state

Sandbox state exists only while the container is active. Understanding this is critical for building reliable applications.

**While the container is active** (typically minutes to hours of activity):

* Files written to `/workspace`, `/tmp`, `/home` remain available
* Background processes continue running
* Shell sessions maintain their working directory and environment
* Code interpreter contexts retain variables and imports

**When the container stops** (due to inactivity or explicit destruction):

* All files are deleted
* All processes terminate
* All shell state resets
* All code interpreter contexts are cleared

The next request creates a fresh container with a clean environment.

## Naming strategies

### Per-user sandboxes

```typescript
const sandbox = getSandbox(env.Sandbox, `user-${userId}`);
```

User's work persists while actively using the sandbox. Good for interactive environments, playgrounds, and notebooks where users work continuously.

### Per-session sandboxes

```typescript
const sessionId = `session-${Date.now()}-${Math.random()}`;
const sandbox = getSandbox(env.Sandbox, sessionId);
// Later:
await sandbox.destroy();
```

Fresh environment each time. Good for one-time execution, CI/CD, and isolated tests.

### Per-task sandboxes

```typescript
const sandbox = getSandbox(env.Sandbox, `build-${repoName}-${commit}`);
```

Idempotent operations with clear task-to-sandbox mapping. Good for builds, pipelines, and background jobs.

## Request routing

The first request to a sandbox determines its geographic location. Subsequent requests route to the same location.

**For global apps**:

* Option 1: Multiple sandboxes per user with region suffix (`user-123-us`, `user-123-eu`)
* Option 2: Single sandbox per user (simpler, but some users see higher latency)

## Lifecycle management

### When to destroy

```typescript
try {
  const sandbox = getSandbox(env.Sandbox, sessionId);
  await sandbox.exec("npm run build");
} finally {
  await sandbox.destroy(); // Clean up temporary sandboxes
}
```

**Destroy when**: Session ends, task completes, resources no longer needed

**Don't destroy**: Personal environments, long-running services

### Managing keepAlive containers

Containers with [`keepAlive: true`](https://developers.cloudflare.com/sandbox/configuration/sandbox-options/#keepalive) require explicit management since they do not timeout automatically:

```typescript
const sandbox = getSandbox(env.Sandbox, 'persistent-task', {
  keepAlive: true
});


// Later, when done with long-running work
await sandbox.setKeepAlive(false); // Allow normal timeout behavior
// Or explicitly destroy:
await sandbox.destroy();
```

### Handling container restarts

Containers restart after inactivity or failures. Design your application to handle state loss:

```typescript
// Check if required files exist before using them
const files = await sandbox.listFiles("/workspace");
if (!files.includes("data.json")) {
  // Reinitialize: container restarted and lost previous state
  await sandbox.writeFile("/workspace/data.json", initialData);
}


await sandbox.exec("python process.py");
```

## Version compatibility

The SDK automatically checks that your npm package version matches the Docker container image version. **Version mismatches can cause features to break or behave unexpectedly.**

**What happens**:

* On sandbox startup, the SDK queries the container's version
* If versions don't match, a warning is logged
* Some features may not work correctly if versions are incompatible

**When you might see warnings**:

* You updated the npm package (`npm install @cloudflare/sandbox@latest`) but forgot to update the `FROM` line in your Dockerfile

**How to fix**: Update your Dockerfile to match your npm package version. For example, if using `@cloudflare/sandbox@0.7.0`:

```dockerfile
# Default image (JavaScript/TypeScript)
FROM docker.io/cloudflare/sandbox:0.7.0


# Or Python image if you need Python support
FROM docker.io/cloudflare/sandbox:0.7.0-python
```

See [Dockerfile reference](https://developers.cloudflare.com/sandbox/configuration/dockerfile/) for details on image variants and extending the base image.

## Best practices

* **Name consistently** - Use clear, predictable naming schemes
* **Clean up temporary sandboxes** - Always destroy when done
* **Reuse long-lived sandboxes** - One per user is often sufficient
* **Batch operations** - Combine commands: `npm install && npm test && npm build`
* **Design for ephemeral state** - Containers restart after inactivity, losing all state

## Related resources

* [Architecture](https://developers.cloudflare.com/sandbox/concepts/architecture/) - How sandboxes fit in the system
* [Container runtime](https://developers.cloudflare.com/sandbox/concepts/containers/) - What runs inside sandboxes
* [Session management](https://developers.cloudflare.com/sandbox/concepts/sessions/) - Advanced state isolation
* [Lifecycle API](https://developers.cloudflare.com/sandbox/api/lifecycle/) - Create and manage sandboxes
* [Sessions API](https://developers.cloudflare.com/sandbox/api/sessions/) - Create and manage execution sessions

</page>

<page>
---
title: Session management · Cloudflare Sandbox SDK docs
description: Sessions are bash shell execution contexts within a sandbox. Think
  of them like terminal tabs or panes in the same container.
lastUpdated: 2025-11-08T10:22:38.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/concepts/sessions/
  md: https://developers.cloudflare.com/sandbox/concepts/sessions/index.md
---

Sessions are bash shell execution contexts within a sandbox. Think of them like terminal tabs or panes in the same container.

* **Sandbox** = A computer (container)
* **Session** = A terminal shell session in that computer

## Default session

Every sandbox has a default session that maintains shell state between commands while the container is active:

```typescript
const sandbox = getSandbox(env.Sandbox, 'my-sandbox');


// These commands run in the default session
await sandbox.exec("cd /app");
await sandbox.exec("pwd");  // Output: /app


await sandbox.exec("export MY_VAR=hello");
await sandbox.exec("echo $MY_VAR");  // Output: hello
```

Working directory, environment variables, and exported variables carry over between commands. This state resets if the container restarts due to inactivity.

### Automatic session creation

The container automatically creates sessions on first use. If you reference a non-existent session ID, the container creates it with default settings:

```typescript
// This session doesn't exist yet
const result = await sandbox.exec('echo hello', { sessionId: 'new-session' });
// Container automatically creates 'new-session' with defaults:
// - cwd: '/workspace'
// - env: {} (empty)
```

This behavior is particularly relevant after deleting a session:

```typescript
// Create and configure a session
const session = await sandbox.createSession({
  id: 'temp',
  env: { MY_VAR: 'value' }
});


// Delete the session
await sandbox.deleteSession('temp');


// Using the same session ID again works - auto-created with defaults
const result = await sandbox.exec('echo $MY_VAR', { sessionId: 'temp' });
// Output: (empty) - MY_VAR is not set in the freshly created session
```

This auto-creation means you can't "break" commands by referencing non-existent sessions. However, custom configuration (environment variables, working directory) is lost after deletion.

## Creating sessions

Create additional sessions for isolated shell contexts:

```typescript
const buildSession = await sandbox.createSession({
  id: "build",
  env: { NODE_ENV: "production" },
  cwd: "/build"
});


const testSession = await sandbox.createSession({
  id: "test",
  env: { NODE_ENV: "test" },
  cwd: "/test"
});


// Different shell contexts
await buildSession.exec("npm run build");
await testSession.exec("npm test");
```

## What's isolated per session

Each session has its own:

**Shell environment**:

```typescript
await session1.exec("export MY_VAR=hello");
await session2.exec("echo $MY_VAR");  // Empty - different shell
```

**Working directory**:

```typescript
await session1.exec("cd /workspace/project1");
await session2.exec("pwd");  // Different working directory
```

**Environment variables** (set via `createSession` options):

```typescript
const session1 = await sandbox.createSession({
  env: { API_KEY: 'key-1' }
});
const session2 = await sandbox.createSession({
  env: { API_KEY: 'key-2' }
});
```

## What's shared

All sessions in a sandbox share:

**Filesystem**:

```typescript
await session1.writeFile('/workspace/file.txt', 'data');
await session2.readFile('/workspace/file.txt');  // Can read it
```

**Processes**:

```typescript
await session1.startProcess('node server.js');
await session2.listProcesses();  // Sees the server
```

## When to use sessions

**Use sessions when**:

* You need isolated shell state for different tasks
* Running parallel operations with different environments
* Keeping AI agent credentials separate from app runtime

**Example - separate dev and runtime environments**:

```typescript
// Phase 1: AI agent writes code (with API keys)
const devSession = await sandbox.createSession({
  id: "dev",
  env: { ANTHROPIC_API_KEY: env.ANTHROPIC_API_KEY }
});
await devSession.exec('ai-tool "build a web server"');


// Phase 2: Run the code (without API keys)
const appSession = await sandbox.createSession({
  id: "app",
  env: { PORT: "3000" }
});
await appSession.exec("node server.js");
```

**Use separate sandboxes when**:

* You need complete isolation (untrusted code)
* Different users require fully separated environments
* Independent resource allocation is needed

## Best practices

### Session cleanup

**Clean up temporary sessions** to free resources while keeping the sandbox running:

```typescript
try {
  const session = await sandbox.createSession({ id: 'temp' });
  await session.exec('command');
} finally {
  await sandbox.deleteSession('temp');
}
```

**Default session cannot be deleted**:

```typescript
// This throws an error
await sandbox.deleteSession('default');
// Error: Cannot delete default session. Use sandbox.destroy() instead.
```

### Filesystem isolation

**Sessions share filesystem** - file operations affect all sessions:

```typescript
// Bad - affects all sessions
await session.exec('rm -rf /workspace/*');


// For untrusted code isolation, use separate sandboxes
const userSandbox = getSandbox(env.Sandbox, userId);
```

## Related resources

* [Sandbox lifecycle](https://developers.cloudflare.com/sandbox/concepts/sandboxes/) - Understanding sandbox management
* [Sessions API](https://developers.cloudflare.com/sandbox/api/sessions/) - Complete session API reference

</page>

<page>
---
title: Terminal connections · Cloudflare Sandbox SDK docs
description: Terminal connections let browser-based UIs interact directly with
  sandbox shells. Instead of executing discrete commands with exec(), a terminal
  connection opens a persistent, bidirectional channel to a bash shell — the
  same model as SSH or a local terminal emulator.
lastUpdated: 2026-02-09T23:08:08.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/concepts/terminal/
  md: https://developers.cloudflare.com/sandbox/concepts/terminal/index.md
---

Terminal connections let browser-based UIs interact directly with sandbox shells. Instead of executing discrete commands with `exec()`, a terminal connection opens a persistent, bidirectional channel to a bash shell — the same model as SSH or a local terminal emulator.

## How terminal connections work

Terminal connections use WebSockets to stream raw bytes between a browser terminal (like [xterm.js](https://xtermjs.org/)) and a pseudo-terminal (PTY) process running inside the sandbox container.

```txt
Browser (xterm.js) <-- WebSocket --> Worker <-- proxy --> Container PTY (bash)
```

1. The browser sends a WebSocket upgrade request to your Worker
2. Your Worker calls `sandbox.terminal(request)`, which proxies the upgrade to the container
3. The container spawns a bash shell attached to a PTY
4. Raw bytes flow bidirectionally — keystrokes in, terminal output out

This is fundamentally different from `exec()`:

* **`exec()`** runs a single command to completion and returns the result
* **`terminal()`** opens a persistent shell where users type commands interactively

## Output buffering

The container buffers terminal output in a ring buffer. When a client disconnects and reconnects, the server replays buffered output so the terminal appears unchanged. This means:

* Short network interruptions are invisible to users
* Reconnected terminals show previous output without re-running commands
* The buffer has a fixed size, so very old output may be lost

No client-side code is needed to handle buffering — the container manages it transparently.

## Automatic reconnection

Network interruptions are common in browser-based applications. Terminal connections handle this through a combination of server-side buffering (described above) and client-side reconnection with exponential backoff.

The `SandboxAddon` for xterm.js implements this automatically. If you are building a custom client, you are responsible for your own reconnection logic — the server-side buffering works regardless of which client connects. Refer to the [WebSocket protocol reference](https://developers.cloudflare.com/sandbox/api/terminal/#websocket-protocol) for details on the connection lifecycle.

## Session isolation

Each [session](https://developers.cloudflare.com/sandbox/concepts/sessions/) can have its own terminal with independent shell state:

```typescript
const devSession = await sandbox.createSession({
  id: "dev",
  cwd: "/workspace/frontend",
  env: { NODE_ENV: "development" },
});


const testSession = await sandbox.createSession({
  id: "test",
  cwd: "/workspace",
  env: { NODE_ENV: "test" },
});


// Each session's terminal has its own working directory,
// environment variables, and command history
```

Multiple browser clients can connect to the same session's terminal simultaneously — they all see the same shell output and can all send input. This enables collaborative terminal use cases.

## WebSocket protocol

Terminal connections use binary WebSocket frames for terminal I/O (for performance) and JSON text frames for control and status messages (for structure). This keeps the data path fast while still allowing structured communication for operations like terminal resizing.

For the full protocol specification, including the connection lifecycle and message formats, refer to the [Terminal API reference](https://developers.cloudflare.com/sandbox/api/terminal/#websocket-protocol).

## When to use terminals vs commands

| Use case | Approach |
| - | - |
| Run a command and get the result | `exec()` or `execStream()` |
| Interactive shell for end users | `terminal()` |
| Long-running process with real-time output | `startProcess()` + `streamProcessLogs()` |
| Collaborative terminal sharing | `terminal()` with shared session |

## Related resources

* [Terminal API reference](https://developers.cloudflare.com/sandbox/api/terminal/) — Method signatures and types
* [Browser terminals](https://developers.cloudflare.com/sandbox/guides/browser-terminals/) — Step-by-step setup guide
* [Session management](https://developers.cloudflare.com/sandbox/concepts/sessions/) — How sessions work
* [Architecture](https://developers.cloudflare.com/sandbox/concepts/architecture/) — Overall SDK design

</page>

<page>
---
title: Dockerfile reference · Cloudflare Sandbox SDK docs
description: Customize the sandbox container image with your own packages,
  tools, and configurations by extending the base runtime image.
lastUpdated: 2026-01-27T13:25:17.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/configuration/dockerfile/
  md: https://developers.cloudflare.com/sandbox/configuration/dockerfile/index.md
---

Customize the sandbox container image with your own packages, tools, and configurations by extending the base runtime image.

## Base images

The Sandbox SDK provides multiple Ubuntu-based image variants. Choose the one that fits your use case:

| Image | Tag suffix | Use case |
| - | - | - |
| Default | (none) | Lean image for JavaScript/TypeScript workloads |
| Python | `-python` | Data science, ML, Python code execution |
| OpenCode | `-opencode` | AI coding agents with OpenCode CLI |

```dockerfile
# Default - lean, no Python
FROM docker.io/cloudflare/sandbox:0.7.0


# Python - includes Python 3.11 + data science packages
FROM docker.io/cloudflare/sandbox:0.7.0-python


# OpenCode - includes OpenCode CLI for AI coding
FROM docker.io/cloudflare/sandbox:0.7.0-opencode
```

Version synchronization required

Always match the Docker image version to your npm package version. If you're using `@cloudflare/sandbox@0.7.0`, use `docker.io/cloudflare/sandbox:0.7.0` (or variant) as your base image.

**Why this matters**: The SDK automatically checks version compatibility on startup. Mismatched versions can cause features to break or behave unexpectedly. If versions don't match, you'll see warnings in your logs.

See [Version compatibility](https://developers.cloudflare.com/sandbox/concepts/sandboxes/#version-compatibility) for troubleshooting version mismatch warnings.

### Default image

The default image is optimized for JavaScript and TypeScript workloads:

* Ubuntu 22.04 LTS base
* Node.js 20 LTS with npm
* Bun 1.x (JavaScript/TypeScript runtime)
* System utilities: curl, wget, git, jq, zip, unzip, file, procps, ca-certificates

### Python image

The `-python` variant includes everything in the default image plus:

* Python 3.11 with pip and venv
* Pre-installed packages: matplotlib, numpy, pandas, ipython

### OpenCode image

The `-opencode` variant includes everything in the default image plus:

* [OpenCode CLI](https://opencode.ai) for AI-powered coding agents

## Creating a custom image

Create a `Dockerfile` in your project root:

```dockerfile
FROM docker.io/cloudflare/sandbox:0.7.0-python


# Install additional Python packages
RUN pip install --no-cache-dir \
    scikit-learn==1.3.0 \
    tensorflow==2.13.0 \
    transformers==4.30.0


# Install Node.js packages globally
RUN npm install -g typescript ts-node prettier


# Install system packages
RUN apt-get update && apt-get install -y \
    postgresql-client \
    redis-tools \
    && rm -rf /var/lib/apt/lists/*
```

Update `wrangler.jsonc` to reference your Dockerfile:

```jsonc
{
  "containers": [
    {
      "class_name": "Sandbox",
      "image": "./Dockerfile",
    },
  ],
}
```

When you run `wrangler dev` or `wrangler deploy`, Wrangler automatically builds your Docker image and pushes it to Cloudflare's container registry. You don't need to manually build or publish images.

## Using arbitrary base images

You can add sandbox capabilities to any Docker image using the standalone binary. This approach lets you use your existing images without depending on the Cloudflare base images:

```dockerfile
FROM your-custom-image:tag


# Copy the sandbox binary from the official image
COPY --from=docker.io/cloudflare/sandbox:0.7.0 /container-server/sandbox /sandbox


ENTRYPOINT ["/sandbox"]
```

The `/sandbox` binary starts the HTTP API server that enables SDK communication. You can optionally run your own startup command:

```dockerfile
FROM node:20-slim


COPY --from=docker.io/cloudflare/sandbox:0.7.0 /container-server/sandbox /sandbox


# Copy your application
COPY . /app
WORKDIR /app


ENTRYPOINT ["/sandbox"]
CMD ["node", "server.js"]
```

When using `CMD`, the sandbox binary runs your command as a child process with proper signal forwarding.

## Custom startup scripts

For more complex startup sequences, create a custom startup script:

```dockerfile
FROM docker.io/cloudflare/sandbox:0.7.0-python


COPY my-app.js /workspace/my-app.js
COPY startup.sh /workspace/startup.sh
RUN chmod +x /workspace/startup.sh


ENTRYPOINT ["/sandbox"]
CMD ["/workspace/startup.sh"]
```

```bash
#!/bin/bash


# Start your services in the background
node /workspace/my-app.js &


# Start additional services
redis-server --daemonize yes
until redis-cli ping; do sleep 1; done


# Keep the script running (the sandbox binary handles the API server)
wait
```

Legacy startup scripts

If you have existing startup scripts that end with `exec bun /container-server/dist/index.js`, they will continue to work for backwards compatibility. However, we recommend migrating to the new approach using `ENTRYPOINT ["/sandbox"]` with `CMD` for your startup script.

## Related resources

* [Image Management](https://developers.cloudflare.com/containers/platform-details/image-management/) - Building and pushing images to Cloudflare's registry
* [Wrangler configuration](https://developers.cloudflare.com/sandbox/configuration/wrangler/) - Using custom images in wrangler.jsonc
* [Docker documentation](https://docs.docker.com/reference/dockerfile/) - Complete Dockerfile syntax
* [Container concepts](https://developers.cloudflare.com/sandbox/concepts/containers/) - Understanding the runtime environment

</page>

<page>
---
title: Environment variables · Cloudflare Sandbox SDK docs
description: Pass configuration, secrets, and runtime settings to your sandboxes
  using environment variables.
lastUpdated: 2026-02-10T11:20:23.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/configuration/environment-variables/
  md: https://developers.cloudflare.com/sandbox/configuration/environment-variables/index.md
---

Pass configuration, secrets, and runtime settings to your sandboxes using environment variables.

## SDK configuration variables

These environment variables configure how the Sandbox SDK behaves. Set these as Worker `vars` in your `wrangler.jsonc` file. The SDK reads them from the Worker's environment bindings.

### SANDBOX\_TRANSPORT

| | |
| - | - |
| **Type** | `"http"` \| `"websocket"` |
| **Default** | `"http"` |

Controls the transport protocol for SDK-to-container communication. WebSocket transport multiplexes all operations over a single persistent connection, avoiding [subrequest limits](https://developers.cloudflare.com/workers/platform/limits/#subrequests) when performing many SDK operations per request.

* wrangler.jsonc

  ```jsonc
  {
    "vars": {
      "SANDBOX_TRANSPORT": "websocket"
    },
  }
  ```

* wrangler.toml

  ```toml
  [vars]
  SANDBOX_TRANSPORT = "websocket"
  ```

See [Transport modes](https://developers.cloudflare.com/sandbox/configuration/transport/) for a complete guide including when to use each transport, performance considerations, and migration instructions.

## Three ways to set environment variables

The Sandbox SDK provides three methods for setting environment variables, each suited for different use cases:

### 1. Sandbox-level with setEnvVars()

Set environment variables globally for all commands in the sandbox:

```typescript
const sandbox = getSandbox(env.Sandbox, "my-sandbox");


// Set once, available for all subsequent commands
await sandbox.setEnvVars({
  DATABASE_URL: env.DATABASE_URL,
  API_KEY: env.API_KEY,
});


await sandbox.exec("python migrate.py"); // Has DATABASE_URL and API_KEY
await sandbox.exec("python seed.py"); // Has DATABASE_URL and API_KEY


// Unset variables by passing undefined
await sandbox.setEnvVars({
  API_KEY: "new-key", // Updates API_KEY
  OLD_SECRET: undefined, // Unsets OLD_SECRET
});
```

**Use when:** You need the same environment variables for multiple commands.

**Unsetting variables**: Pass `undefined` or `null` to unset environment variables:

```typescript
await sandbox.setEnvVars({
  API_KEY: 'new-key',     // Sets API_KEY
  OLD_SECRET: undefined,  // Unsets OLD_SECRET
  DEBUG_MODE: null        // Unsets DEBUG_MODE
});
```

### 2. Per-command with exec() options

Pass environment variables for a specific command:

```typescript
await sandbox.exec("node app.js", {
  env: {
    NODE_ENV: "production",
    PORT: "3000",
  },
});


// Also works with startProcess()
await sandbox.startProcess("python server.py", {
  env: {
    DATABASE_URL: env.DATABASE_URL,
  },
});
```

**Use when:** You need different environment variables for different commands, or want to override sandbox-level variables.

Note

Per-command environment variables with `undefined` values are skipped (treated as "not configured"), unlike `setEnvVars()` where `undefined` explicitly unsets a variable.

### 3. Session-level with createSession()

Create an isolated session with its own environment variables:

```typescript
const session = await sandbox.createSession({
  env: {
    DATABASE_URL: env.DATABASE_URL,
    SECRET_KEY: env.SECRET_KEY,
  },
});


// All commands in this session have these vars
await session.exec("python migrate.py");
await session.exec("python seed.py");
```

**Use when:** You need isolated execution contexts with different environment variables running concurrently.

## Unsetting environment variables

The Sandbox SDK supports unsetting environment variables by passing `undefined` or `null` values. This enables idiomatic JavaScript patterns for managing configuration:

```typescript
await sandbox.setEnvVars({
  // Set new values
  API_KEY: 'new-key',
  DATABASE_URL: env.DATABASE_URL,


  // Unset variables (removes them from the environment)
  OLD_API_KEY: undefined,
  TEMP_TOKEN: null
});
```

**Before this change**: Passing `undefined` values would throw a runtime error.

**After this change**: `undefined` and `null` values run `unset VARIABLE_NAME` in the shell.

### Use cases for unsetting

**Remove sensitive data after use:**

```typescript
// Use a temporary token
await sandbox.setEnvVars({ TEMP_TOKEN: 'abc123' });
await sandbox.exec('curl -H "Authorization: $TEMP_TOKEN" api.example.com');


// Clean up the token
await sandbox.setEnvVars({ TEMP_TOKEN: undefined });
```

**Conditional environment setup:**

```typescript
await sandbox.setEnvVars({
  API_KEY: env.API_KEY,
  DEBUG_MODE: env.NODE_ENV === 'development' ? 'true' : undefined,
  PROFILING: env.ENABLE_PROFILING ? 'true' : undefined
});
```

**Reset to system defaults:**

```typescript
// Unset to fall back to container's default NODE_ENV
await sandbox.setEnvVars({ NODE_ENV: undefined });
```

## Common patterns

### Pass Worker secrets to sandbox

Securely pass secrets from your Worker to the sandbox. First, set secrets using Wrangler:

```bash
wrangler secret put OPENAI_API_KEY
wrangler secret put DATABASE_URL
```

Then pass them to your sandbox:

```typescript
import { getSandbox } from "@cloudflare/sandbox";


interface Env {
  Sandbox: DurableObjectNamespace;
  OPENAI_API_KEY: string;
  DATABASE_URL: string;
}


export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const sandbox = getSandbox(env.Sandbox, "user-sandbox");


    // Option 1: Set globally for all commands
    await sandbox.setEnvVars({
      OPENAI_API_KEY: env.OPENAI_API_KEY,
      DATABASE_URL: env.DATABASE_URL,
    });
    await sandbox.exec("python analyze.py");


    // Option 2: Pass per-command
    await sandbox.exec("python analyze.py", {
      env: {
        OPENAI_API_KEY: env.OPENAI_API_KEY,
      },
    });


    return Response.json({ success: true });
  },
};
```

### Combine default and specific variables

```typescript
const defaults = { NODE_ENV: "production", LOG_LEVEL: "info" };


await sandbox.exec("npm start", {
  env: { ...defaults, PORT: "3000", API_KEY: env.API_KEY },
});
```

### Multiple isolated sessions

Run different tasks with different environment variables concurrently:

```typescript
// Production database session
const prodSession = await sandbox.createSession({
  env: { DATABASE_URL: env.PROD_DATABASE_URL },
});


// Staging database session
const stagingSession = await sandbox.createSession({
  env: { DATABASE_URL: env.STAGING_DATABASE_URL },
});


// Run migrations on both concurrently
await Promise.all([
  prodSession.exec("python migrate.py"),
  stagingSession.exec("python migrate.py"),
]);
```

### Configure transport mode

Set `SANDBOX_TRANSPORT` in your Worker's `vars` to switch between HTTP and WebSocket transport. See [Transport modes](https://developers.cloudflare.com/sandbox/configuration/transport/) for details on when and how to configure each transport.

### Bucket mounting credentials

When mounting S3-compatible object storage, the SDK uses **s3fs-fuse** under the hood, which requires AWS-style credentials. For R2, generate API tokens from the Cloudflare dashboard and provide them using AWS environment variable names:

**Get R2 API tokens:**

1. Go to [**R2** > **Overview**](https://dash.cloudflare.com/?to=/:account/r2) in the Cloudflare dashboard
2. Select **Manage R2 API Tokens**
3. Create a token with **Object Read & Write** permissions
4. Copy the **Access Key ID** and **Secret Access Key**

**Set credentials as Worker secrets:**

```bash
wrangler secret put AWS_ACCESS_KEY_ID
# Paste your R2 Access Key ID


wrangler secret put AWS_SECRET_ACCESS_KEY
# Paste your R2 Secret Access Key
```

Production only

Bucket mounting requires production deployment. It does not work with `wrangler dev` due to FUSE support limitations. See [Mount buckets guide](https://developers.cloudflare.com/sandbox/guides/mount-buckets/) for details.

**Mount buckets with automatic credential detection:**

```typescript
import { getSandbox } from "@cloudflare/sandbox";


interface Env {
  Sandbox: DurableObjectNamespace;
  AWS_ACCESS_KEY_ID: string;
  AWS_SECRET_ACCESS_KEY: string;
}


export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const sandbox = getSandbox(env.Sandbox, "data-processor");


    // Credentials automatically detected from environment
    await sandbox.mountBucket("my-r2-bucket", "/data", {
      endpoint: "https://YOUR_ACCOUNT_ID.r2.cloudflarestorage.com",
    });


    // Access mounted bucket using standard file operations
    await sandbox.exec("python", { args: ["process.py", "/data/input.csv"] });


    return Response.json({ success: true });
  },
};
```

The SDK automatically detects `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` from your Worker's environment when you call `mountBucket()` without explicit credentials.

**Pass credentials explicitly** (if using custom secret names):

```typescript
await sandbox.mountBucket("my-r2-bucket", "/data", {
  endpoint: "https://YOUR_ACCOUNT_ID.r2.cloudflarestorage.com",
  credentials: {
    accessKeyId: env.R2_ACCESS_KEY_ID,
    secretAccessKey: env.R2_SECRET_ACCESS_KEY,
  },
});
```

AWS nomenclature for R2

The SDK uses AWS-style credential names (`AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`) because bucket mounting is powered by **s3fs-fuse**, which expects S3-compatible credentials. R2's API tokens work with this format since R2 implements the S3 API.

See [Mount buckets guide](https://developers.cloudflare.com/sandbox/guides/mount-buckets/) for complete bucket mounting documentation.

## Environment variable precedence

When the same variable is set at multiple levels, the most specific level takes precedence:

1. **Command-level** (highest) - Passed to `exec()` or `startProcess()` options
2. **Sandbox or session-level** - Set with `setEnvVars()`
3. **Container default** - Built into the Docker image with `ENV`
4. **System default** (lowest) - Operating system defaults

Example:

```typescript
// In Dockerfile: ENV NODE_ENV=development


// Sandbox-level
await sandbox.setEnvVars({ NODE_ENV: "staging" });


// Command-level overrides all
await sandbox.exec("node app.js", {
  env: { NODE_ENV: "production" }, // This wins
});
```

## Related resources

* [Transport modes](https://developers.cloudflare.com/sandbox/configuration/transport/) - Configure HTTP vs WebSocket transport
* [Wrangler configuration](https://developers.cloudflare.com/sandbox/configuration/wrangler/) - Setting Worker-level environment
* [Secrets](https://developers.cloudflare.com/workers/configuration/secrets/) - Managing sensitive data
* [Sessions API](https://developers.cloudflare.com/sandbox/api/sessions/) - Session-level environment variables
* [Security model](https://developers.cloudflare.com/sandbox/concepts/security/) - Understanding data isolation

</page>

<page>
---
title: Sandbox options · Cloudflare Sandbox SDK docs
description: Configure sandbox behavior by passing options when creating a
  sandbox instance with getSandbox().
lastUpdated: 2026-02-06T17:12:38.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/configuration/sandbox-options/
  md: https://developers.cloudflare.com/sandbox/configuration/sandbox-options/index.md
---

Configure sandbox behavior by passing options when creating a sandbox instance with `getSandbox()`.

## Available options

```ts
import { getSandbox } from '@cloudflare/sandbox';


const sandbox = getSandbox(binding, sandboxId, options?: SandboxOptions);
```

### keepAlive

**Type**: `boolean` **Default**: `false`

Keep the container alive indefinitely by preventing automatic shutdown. When `true`, the container automatically sends heartbeat pings every 30 seconds to prevent eviction and will never auto-timeout.

**How it works**: The sandbox automatically schedules lightweight ping requests to the container every 30 seconds. This prevents the container from being evicted due to inactivity while minimizing resource overhead. You can also enable/disable keepAlive dynamically using [`setKeepAlive()`](https://developers.cloudflare.com/sandbox/api/lifecycle/#setkeepalive).

The `keepAlive` flag persists across Durable Object hibernation and wakeup cycles. Once enabled, you do not need to re-set it after the sandbox wakes from hibernation.

* JavaScript

  ```js
  // For long-running processes that need the container to stay alive
  const sandbox = getSandbox(env.Sandbox, "user-123", {
    keepAlive: true,
  });


  // Run your long-running process
  await sandbox.startProcess("python long_running_script.py");


  // Important: Must explicitly destroy when done
  try {
    // Your work here
  } finally {
    await sandbox.destroy(); // Required to prevent containers running indefinitely
  }
  ```

* TypeScript

  ```ts
  // For long-running processes that need the container to stay alive
  const sandbox = getSandbox(env.Sandbox, 'user-123', {
    keepAlive: true
  });


  // Run your long-running process
  await sandbox.startProcess('python long_running_script.py');


  // Important: Must explicitly destroy when done
  try {
    // Your work here
  } finally {
    await sandbox.destroy(); // Required to prevent containers running indefinitely
  }
  ```

Resource management with keepAlive

When `keepAlive: true` is set, containers automatically send heartbeat pings to prevent eviction and will not automatically timeout. They must be explicitly destroyed using `destroy()` or disabled with `setKeepAlive(false)` to prevent containers running indefinitely and counting toward your account limits.

### sleepAfter

**Type**: `string | number` **Default**: `"10m"` (10 minutes)

Duration of inactivity before the sandbox automatically sleeps. Accepts duration strings (`"30s"`, `"5m"`, `"1h"`) or numbers (seconds).

Bug fix in v0.2.17

Prior to v0.2.17, the `sleepAfter` option passed to `getSandbox()` was ignored due to a timing issue. The option is now properly applied when creating sandbox instances.

* JavaScript

  ```js
  // Sleep after 30 seconds of inactivity
  const sandbox = getSandbox(env.Sandbox, "user-123", {
    sleepAfter: "30s",
  });


  // Sleep after 5 minutes (using number)
  const sandbox2 = getSandbox(env.Sandbox, "user-456", {
    sleepAfter: 300, // 300 seconds = 5 minutes
  });
  ```

* TypeScript

  ```ts
  // Sleep after 30 seconds of inactivity
  const sandbox = getSandbox(env.Sandbox, 'user-123', {
    sleepAfter: '30s'
  });


  // Sleep after 5 minutes (using number)
  const sandbox2 = getSandbox(env.Sandbox, 'user-456', {
    sleepAfter: 300  // 300 seconds = 5 minutes
  });
  ```

Ignored when keepAlive is true

When `keepAlive: true` is set, `sleepAfter` is ignored and the sandbox never sleeps automatically.

### containerTimeouts

**Type**: `object`

Configure timeouts for container startup operations.

* JavaScript

  ```js
  // Extended startup with custom Dockerfile work
  // (installing packages, starting services before SDK)
  const sandbox = getSandbox(env.Sandbox, "data-processor", {
    containerTimeouts: {
      portReadyTimeoutMS: 180_000, // 3 minutes for startup work
    },
  });


  // Wait longer during traffic spikes
  const sandbox2 = getSandbox(env.Sandbox, "user-env", {
    containerTimeouts: {
      instanceGetTimeoutMS: 60_000, // 1 minute for provisioning
    },
  });
  ```

* TypeScript

  ```ts
  // Extended startup with custom Dockerfile work
  // (installing packages, starting services before SDK)
  const sandbox = getSandbox(env.Sandbox, 'data-processor', {
    containerTimeouts: {
      portReadyTimeoutMS: 180_000  // 3 minutes for startup work
    }
  });


  // Wait longer during traffic spikes
  const sandbox2 = getSandbox(env.Sandbox, 'user-env', {
    containerTimeouts: {
      instanceGetTimeoutMS: 60_000   // 1 minute for provisioning
    }
  });
  ```

**Available timeout options**:

* `instanceGetTimeoutMS` - How long to wait for Cloudflare to provision a new container instance. Increase during traffic spikes when many containers provision simultaneously. **Default**: `30000` (30 seconds)
* `portReadyTimeoutMS` - How long to wait for the sandbox API to become ready. Increase if you extend the base Dockerfile with custom startup work (installing packages, starting services). **Default**: `90000` (90 seconds)

**Environment variable overrides**:

* `SANDBOX_INSTANCE_TIMEOUT_MS` - Override `instanceGetTimeoutMS`
* `SANDBOX_PORT_TIMEOUT_MS` - Override `portReadyTimeoutMS`

Precedence: `options` > `env vars` > SDK defaults

### Logging

**Type**: Environment variables

Control SDK logging for debugging and monitoring. Set these in your Worker's `wrangler.jsonc` file.

**Available options**:

* `SANDBOX_LOG_LEVEL` - Minimum log level: `debug`, `info`, `warn`, `error`. **Default**: `info`
* `SANDBOX_LOG_FORMAT` - Output format: `json`, `pretty`. **Default**: `json`

- wrangler.jsonc

  ```jsonc
  {
    "vars": {
      "SANDBOX_LOG_LEVEL": "debug",
      "SANDBOX_LOG_FORMAT": "pretty"
    }
  }
  ```

- wrangler.toml

  ```toml
  [vars]
  SANDBOX_LOG_LEVEL = "debug"
  SANDBOX_LOG_FORMAT = "pretty"
  ```

Read at startup

Logging configuration is read when your Worker starts and cannot be changed at runtime. Changes require redeploying your Worker.

Use `debug` + `pretty` for local development. Use `info` or `warn` + `json` for production (structured logging).

### normalizeId

**Type**: `boolean` **Default**: `false` (will become `true` in a future version)

Lowercase sandbox IDs when creating sandboxes. When `true`, the ID you provide is lowercased before creating the Durable Object (e.g., "MyProject-123" → "myproject-123").

**Why this matters**: Preview URLs extract the sandbox ID from the hostname, which is always lowercase due to DNS case-insensitivity. Without normalization, a sandbox created with "MyProject-123" becomes unreachable via preview URL because the URL routing looks for "myproject-123" (different Durable Object).

* JavaScript

  ```js
  // Without normalization (default)
  const sandbox1 = getSandbox(env.Sandbox, "MyProject-123");
  // Creates Durable Object with ID: "MyProject-123"
  // Preview URL: 8000-myproject-123.example.com
  // Problem: URL routes to "myproject-123" (different DO)


  // With normalization
  const sandbox2 = getSandbox(env.Sandbox, "MyProject-123", {
    normalizeId: true,
  });
  // Creates Durable Object with ID: "myproject-123"
  // Preview URL: 8000-myproject-123.example.com
  // Works: URL routes to "myproject-123" (same DO)
  ```

* TypeScript

  ```ts
  // Without normalization (default)
  const sandbox1 = getSandbox(env.Sandbox, 'MyProject-123');
  // Creates Durable Object with ID: "MyProject-123"
  // Preview URL: 8000-myproject-123.example.com
  // Problem: URL routes to "myproject-123" (different DO)


  // With normalization
  const sandbox2 = getSandbox(env.Sandbox, 'MyProject-123', {
    normalizeId: true
  });
  // Creates Durable Object with ID: "myproject-123"
  // Preview URL: 8000-myproject-123.example.com
  // Works: URL routes to "myproject-123" (same DO)
  ```

Different normalizeId values = different sandboxes

`getSandbox(ns, 'MyProject-123')` and `getSandbox(ns, 'MyProject-123', { normalizeId: true })` create two separate Durable Objects. If you have existing sandboxes with uppercase IDs, enabling normalization creates new sandboxes—you won't access the old ones.

Future default

In a future SDK version, `normalizeId` will default to `true`. All sandbox IDs will be lowercase regardless of input casing. Use lowercase IDs now or explicitly set `normalizeId: true` to prepare for this change.

## When to use normalizeId

Use `normalizeId: true` when:

* **Using preview URLs** - Required for port exposure if your IDs contain uppercase letters
* **New projects** - Either enable this option OR use lowercase IDs from the start (both work)
* **Migrating existing code** - Create new sandboxes with this enabled; old uppercase sandboxes will eventually be destroyed (explicitly or after timeout)

**Best practice**: Use lowercase IDs from the start (`'my-project-123'` instead of `'MyProject-123'`).

## When to use sleepAfter

Use custom `sleepAfter` values to:

* **Reduce costs** - Shorter timeouts (e.g., `"1m"`) for infrequent workloads
* **Extend availability** - Longer timeouts (e.g., `"30m"`) for interactive workflows
* **Balance performance** - Fine-tune based on your application's usage patterns

The default 10-minute timeout works well for most applications. Adjust based on your needs.

## When to use keepAlive

Use `keepAlive: true` for:

* **Long-running builds** - CI/CD pipelines that may have idle periods between steps
* **Batch processing** - Jobs that process data in waves with gaps between batches
* **Monitoring tasks** - Processes that periodically check external services
* **Interactive sessions** - User-driven workflows where the container should remain available

With `keepAlive`, containers send automatic heartbeat pings every 30 seconds to prevent eviction and never sleep automatically. Use for scenarios where you control the lifecycle explicitly.

## Related resources

* [Expose services guide](https://developers.cloudflare.com/sandbox/guides/expose-services/) - Using `normalizeId` with preview URLs
* [Preview URLs concept](https://developers.cloudflare.com/sandbox/concepts/preview-urls/) - Understanding DNS case-insensitivity
* [Background processes guide](https://developers.cloudflare.com/sandbox/guides/background-processes/) - Using `keepAlive` with long-running processes
* [Lifecycle API](https://developers.cloudflare.com/sandbox/api/lifecycle/) - Create and manage sandboxes with `setKeepAlive()`
* [Sandboxes concept](https://developers.cloudflare.com/sandbox/concepts/sandboxes/) - Understanding sandbox lifecycle

</page>

<page>
---
title: Transport modes · Cloudflare Sandbox SDK docs
description: Configure how the Sandbox SDK communicates with containers using
  transport modes.
lastUpdated: 2026-02-10T11:20:23.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/configuration/transport/
  md: https://developers.cloudflare.com/sandbox/configuration/transport/index.md
---

Configure how the Sandbox SDK communicates with containers using transport modes.

## Overview

The Sandbox SDK supports two transport modes for communication between the Durable Object and the container:

* **HTTP transport** (default) - Each SDK operation makes a separate HTTP request to the container.
* **WebSocket transport** - All SDK operations are multiplexed over a single persistent WebSocket connection.

## When to use WebSocket transport

Use WebSocket transport when your Worker or Durable Object makes many SDK operations per request. This avoids hitting [subrequest limits](https://developers.cloudflare.com/workers/platform/limits/#subrequests).

### Subrequest limits

Cloudflare Workers have subrequest limits that apply when making requests to external services, including container API calls:

* **Workers Free**: 50 subrequests per request
* **Workers Paid**: 1,000 subrequests per request

With HTTP transport (default), each SDK operation (`exec()`, `readFile()`, `writeFile()`, etc.) consumes one subrequest. Applications that perform many sandbox operations in a single request can hit these limits.

### How WebSocket transport helps

WebSocket transport establishes a single persistent connection to the container and multiplexes all SDK operations over it. The WebSocket upgrade counts as **one subrequest** regardless of how many operations you perform afterwards.

**Example with HTTP transport (4 subrequests):**

```typescript
await sandbox.exec("python setup.py");
await sandbox.writeFile("/app/config.json", config);
await sandbox.exec("python process.py");
const result = await sandbox.readFile("/app/output.txt");
```

**Same code with WebSocket transport (1 subrequest):**

```typescript
// Identical code - transport is configured via environment variable
await sandbox.exec("python setup.py");
await sandbox.writeFile("/app/config.json", config);
await sandbox.exec("python process.py");
const result = await sandbox.readFile("/app/output.txt");
```

## Configuration

Set the `SANDBOX_TRANSPORT` environment variable in your Worker's configuration. The SDK reads this from the Worker environment bindings (not from inside the container).

### HTTP transport (default)

HTTP transport is the default and requires no additional configuration.

### WebSocket transport

Enable WebSocket transport by adding `SANDBOX_TRANSPORT` to your Worker's `vars`:

* wrangler.jsonc

  ```jsonc
  {
    "name": "my-sandbox-worker",
    "main": "src/index.ts",
    "compatibility_date": "2025-10-13",
    "vars": {
      "SANDBOX_TRANSPORT": "websocket"
    },
    "containers": [
      {
        "class_name": "Sandbox",
        "image": "./Dockerfile",
      },
    ],
    "durable_objects": {
      "bindings": [
        {
          "class_name": "Sandbox",
          "name": "Sandbox",
        },
      ],
    },
  }
  ```

* wrangler.toml

  ```toml
  name = "my-sandbox-worker"
  main = "src/index.ts"
  compatibility_date = "2025-10-13"


  [vars]
  SANDBOX_TRANSPORT = "websocket"


  [[containers]]
  class_name = "Sandbox"
  image = "./Dockerfile"


  [[durable_objects.bindings]]
  class_name = "Sandbox"
  name = "Sandbox"
  ```

No application code changes are needed. The SDK automatically uses the configured transport for all operations.

## Transport behavior

### Connection lifecycle

**HTTP transport:**

* Creates a new HTTP request for each SDK operation
* No persistent connection
* Each request is independent and stateless

**WebSocket transport:**

* Establishes a WebSocket connection on the first SDK operation
* Maintains the persistent connection for all subsequent operations
* Connection is closed when the sandbox sleeps or is evicted
* Automatically reconnects if the connection drops

### Streaming support

Both transports support streaming operations (like `exec()` with real-time output):

* **HTTP transport** - Uses Server-Sent Events (SSE)
* **WebSocket transport** - Uses WebSocket streaming messages

Your code remains identical regardless of transport mode.

### Error handling

Both transports provide identical error handling behavior. The SDK automatically retries on transient errors (like 503 responses) with exponential backoff.

WebSocket-specific behavior:

* Connection failures trigger automatic reconnection
* The SDK transparently handles WebSocket disconnections
* In-flight operations are not lost during reconnection

## Choosing a transport

| Scenario | Recommended transport |
| - | - |
| Many SDK operations per request | WebSocket |
| Running inside Workers or Durable Objects | WebSocket |
| Approaching subrequest limits | WebSocket |
| Simple, infrequent sandbox usage | HTTP (default) |
| Debugging or inspecting individual requests | HTTP (default) |

Default is sufficient for most use cases

HTTP transport works well for most applications. Only switch to WebSocket transport if you are hitting subrequest limits or performing many rapid sandbox operations per request.

## Migration guide

Switching between transports requires no code changes.

### Switch from HTTP to WebSocket

Add `SANDBOX_TRANSPORT` to your `wrangler.jsonc`:

* wrangler.jsonc

  ```jsonc
  {
    "vars": {
      "SANDBOX_TRANSPORT": "websocket"
    },
  }
  ```

* wrangler.toml

  ```toml
  [vars]
  SANDBOX_TRANSPORT = "websocket"
  ```

Then deploy:

```bash
npx wrangler deploy
```

### Switch from WebSocket to HTTP

Remove the `SANDBOX_TRANSPORT` variable (or set it to `"http"`):

* wrangler.jsonc

  ```jsonc
  {
    "vars": {
      // Remove SANDBOX_TRANSPORT or set to "http"
    },
  }
  ```

* wrangler.toml

  ```toml
  vars = { }
  ```

## Related resources

* [Wrangler configuration](https://developers.cloudflare.com/sandbox/configuration/wrangler/) - Complete Worker configuration
* [Environment variables](https://developers.cloudflare.com/sandbox/configuration/environment-variables/) - Passing configuration to sandboxes
* [Workers subrequest limits](https://developers.cloudflare.com/workers/platform/limits/#subrequests) - Understanding subrequest limits
* [Architecture](https://developers.cloudflare.com/sandbox/concepts/architecture/) - How Sandbox SDK components communicate

</page>

<page>
---
title: Beta Information · Cloudflare Sandbox SDK docs
description: Sandbox SDK is currently in open beta. This means the product is
  publicly available and ready to use, but we're actively gathering feedback and
  may make changes based on what we learn.
lastUpdated: 2025-10-15T17:28:03.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/platform/beta-info/
  md: https://developers.cloudflare.com/sandbox/platform/beta-info/index.md
---

Sandbox SDK is currently in open beta. This means the product is publicly available and ready to use, but we're actively gathering feedback and may make changes based on what we learn.

## What to Expect

During the beta period:

* **API stability** - The core API is stable, but we may introduce new features or adjust existing ones based on feedback
* **Production use** - You can use Sandbox SDK in production, but be aware of potential changes
* **Active development** - We're continuously improving performance, adding features, and fixing bugs
* **Documentation updates** - Guides and examples will be refined as we learn from real-world usage

## Known Limitations

See [Containers Beta Information](https://developers.cloudflare.com/containers/beta-info/) for current limitations and known issues, as Sandbox SDK inherits the same constraints.

## Feedback Wanted

We'd love to hear about your experience with Sandbox SDK:

* What are you building?
* What features would be most valuable?
* What challenges have you encountered?
* What instance sizes do you need?

Share your feedback:

* [GitHub Issues](https://github.com/cloudflare/sandbox-sdk/issues) - Report bugs or request features
* [Developer Discord](https://discord.cloudflare.com) - Chat with the team and community
* [Community Forum](https://community.cloudflare.com) - Discuss use cases and best practices

Check the [GitHub repository](https://github.com/cloudflare/sandbox-sdk) for the latest updates and upcoming features.

</page>

<page>
---
title: Wrangler configuration · Cloudflare Sandbox SDK docs
description: "The minimum required configuration for using Sandbox SDK:"
lastUpdated: 2026-02-10T11:20:23.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/configuration/wrangler/
  md: https://developers.cloudflare.com/sandbox/configuration/wrangler/index.md
---

## Minimal configuration

The minimum required configuration for using Sandbox SDK:

* wrangler.jsonc

  ```jsonc
  {
    "name": "my-sandbox-worker",
    "main": "src/index.ts",
    "compatibility_date": "2025-10-13",
    "compatibility_flags": ["nodejs_compat"],
    "containers": [
      {
        "class_name": "Sandbox",
        "image": "./Dockerfile",
      },
    ],
    "durable_objects": {
      "bindings": [
        {
          "class_name": "Sandbox",
          "name": "Sandbox",
        },
      ],
    },
    "migrations": [
      {
        "new_sqlite_classes": ["Sandbox"],
        "tag": "v1",
      },
    ],
  }
  ```

* wrangler.toml

  ```toml
  name = "my-sandbox-worker"
  main = "src/index.ts"
  compatibility_date = "2025-10-13"
  compatibility_flags = [ "nodejs_compat" ]


  [[containers]]
  class_name = "Sandbox"
  image = "./Dockerfile"


  [[durable_objects.bindings]]
  class_name = "Sandbox"
  name = "Sandbox"


  [[migrations]]
  new_sqlite_classes = [ "Sandbox" ]
  tag = "v1"
  ```

## Required settings

The Sandbox SDK is built on Cloudflare Containers. Your configuration requires three sections:

1. **containers** - Define the container image (your runtime environment)
2. **durable\_objects.bindings** - Bind the Sandbox Durable Object to your Worker
3. **migrations** - Initialize the Durable Object class

The minimal configuration shown above includes all required settings. For detailed configuration options, refer to the [Containers configuration documentation](https://developers.cloudflare.com/workers/wrangler/configuration/#containers).

## Troubleshooting

### Binding not found

**Error**: `TypeError: env.Sandbox is undefined`

**Solution**: Ensure your `wrangler.jsonc` includes the Durable Objects binding:

* wrangler.jsonc

  ```jsonc
  {
    "durable_objects": {
      "bindings": [
        {
          "class_name": "Sandbox",
          "name": "Sandbox",
        },
      ],
    },
  }
  ```

* wrangler.toml

  ```toml
  [[durable_objects.bindings]]
  class_name = "Sandbox"
  name = "Sandbox"
  ```

### Missing migrations

**Error**: Durable Object not initialized

**Solution**: Add migrations for the Sandbox class:

* wrangler.jsonc

  ```jsonc
  {
    "migrations": [
      {
        "new_sqlite_classes": ["Sandbox"],
        "tag": "v1",
      },
    ],
  }
  ```

* wrangler.toml

  ```toml
  [[migrations]]
  new_sqlite_classes = [ "Sandbox" ]
  tag = "v1"
  ```

## Related resources

* [Transport modes](https://developers.cloudflare.com/sandbox/configuration/transport/) - Configure HTTP vs WebSocket transport
* [Wrangler documentation](https://developers.cloudflare.com/workers/wrangler/) - Complete Wrangler reference
* [Durable Objects setup](https://developers.cloudflare.com/durable-objects/get-started/) - DO-specific configuration
* [Dockerfile reference](https://developers.cloudflare.com/sandbox/configuration/dockerfile/) - Custom container images
* [Environment variables](https://developers.cloudflare.com/sandbox/configuration/environment-variables/) - Passing configuration to sandboxes
* [Get Started guide](https://developers.cloudflare.com/sandbox/get-started/) - Initial setup walkthrough

</page>

<page>
---
title: Limits · Cloudflare Sandbox SDK docs
description: Since the Sandbox SDK is built on top of the Containers platform,
  it shares the same underlying platform characteristics. Refer to these pages
  to understand how pricing and limits work for your sandbox deployments.
lastUpdated: 2026-02-10T11:20:23.000Z
chatbotDeprioritize: false
source_url:
  html: https://developers.cloudflare.com/sandbox/platform/limits/
  md: https://developers.cloudflare.com/sandbox/platform/limits/index.md
---

Since the Sandbox SDK is built on top of the [Containers](https://developers.cloudflare.com/containers/) platform, it shares the same underlying platform characteristics. Refer to these pages to understand how pricing and limits work for your sandbox deployments.

## Container limits

Refer to [Containers limits](https://developers.cloudflare.com/containers/platform-details/limits/) for complete details on:

* Memory, vCPU, and disk limits for concurrent container instances
* Instance types and their resource allocations
* Image size and storage limits

## Workers and Durable Objects limits

When using the Sandbox SDK from Workers or Durable Objects, you are subject to [Workers subrequest limits](https://developers.cloudflare.com/workers/platform/limits/#subrequests). By default, the SDK uses HTTP transport where each operation (`exec()`, `readFile()`, `writeFile()`, etc.) counts as one subrequest.

### Subrequest limits

* **Workers Free**: 50 subrequests per request
* **Workers Paid**: 1,000 subrequests per request

### Avoid subrequest limits with WebSocket transport

Enable WebSocket transport to multiplex all SDK calls over a single persistent connection:

* wrangler.jsonc

  ```jsonc
  {
    "vars": {
      "SANDBOX_TRANSPORT": "websocket"
    },
  }
  ```

* wrangler.toml

  ```toml
  [vars]
  SANDBOX_TRANSPORT = "websocket"
  ```

With WebSocket transport enabled:

* The WebSocket upgrade counts as one subrequest
* All subsequent SDK operations use the existing connection (no additional subrequests)
* Ideal for workflows with many SDK operations per request

See [Transport modes](https://developers.cloudflare.com/sandbox/configuration/transport/) for a complete guide.

## Best practices

To work within these limits:

* **Right-size your instances** - Choose the appropriate [instance type](https://developers.cloudflare.com/containers/platform-details/limits/#instance-types) based on your workload requirements
* **Clean up unused sandboxes** - Terminate sandbox sessions when they are no longer needed to free up resources
* **Optimize images** - Keep your [custom Dockerfiles](https://developers.cloudflare.com/sandbox/configuration/dockerfile/) lean to reduce image size
* **Use WebSocket transport for high-frequency operations** - Enable `SANDBOX_TRANSPORT=websocket` to avoid subrequest limits when making many SDK calls per request

</page>

<page>
---
title: Pricing · Cloudflare Sandbox SDK do